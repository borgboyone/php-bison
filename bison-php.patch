diff -ruN bison-3.0.4/data/lalr1.php bison-3.0.4b/data/lalr1.php
--- bison-3.0.4/data/lalr1.php	1969-12-31 19:00:00.000000000 -0500
+++ bison-3.0.4b/data/lalr1.php	2015-12-28 19:52:37.293149000 -0500
@@ -0,0 +1,71 @@
+m4_include(b4_pkgdatadir/[c.m4])
+
+# b4_case(LABEL, STATEMENTS)
+# --------------------------
+m4_pushdef([b4_case],
+[  case m4_decr($1):
+$2
+b4_syncline([@oline@], [@ofile@])
+    break;])
+
+# b4_symbol_value(VAL, [TYPE])
+# ----------------------------
+# Given a semantic value VAL ($$, $1 etc.), extract its value of type
+# TYPE if TYPE is given, otherwise just return VAL.  The result can be
+# used safetly, it is put in parens to avoid nasty precedence issues.
+# TYPE is *not* put in braces, provide some if needed.
+m4_pushdef([b4_symbol_value],
+[$1[]m4_ifval([$2], [.$2])])
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+# b4_lhs_value([TYPE])
+# --------------------
+# Expansion of $<TYPE>$.
+m4_define([b4_lhs_value],
+[b4_symbol_value($m4_quote(b4_prefix)val, [$1])])
+
+
+# b4_rhs_value(RULE-LENGTH, NUM, [TYPE])
+# --------------------------------------
+# Expansion of $<TYPE>NUM, where the current rule has RULE-LENGTH
+# symbols on RHS.
+m4_define([b4_rhs_value],
+          [b4_symbol_value([$b4_prefix@{b4_subtract([$2], [0])@}], [$3])])
+
+
+## ----------- ##
+## Locations.  ##
+## ----------- ##
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[$m4_quote(b4_prefix)loc])
+
+
+# b4_rhs_location(RULE-LENGTH, NUM)
+# ---------------------------------
+# Expansion of @NUM, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+          [$m4_quote(b4_prefix)loc@{b4_subtract([$2], [0])@}])
+
+b4_output_begin([b4_parser_file_name])
+<?php
+
+$reduceCallback = function ($ruleNumber, $b4_prefix, b4_lhs_location) {
+  b4_user_pre_prologue
+  switch ($ruleNumber) {
+  	b4_user_actions
+    default: b4_lhs_value() = count($m4_quote(b4_prefix)) ? b4_rhs_value(0, 0) : null; break;
+  }
+  return $m4_quote(b4_prefix)val;
+}
+
+?>
+b4_output_end()
diff -ruN bison-3.0.4/data/php-skel.m4 bison-3.0.4b/data/php-skel.m4
--- bison-3.0.4/data/php-skel.m4	1969-12-31 19:00:00.000000000 -0500
+++ bison-3.0.4b/data/php-skel.m4	2015-12-24 10:04:36.844314600 -0500
@@ -0,0 +1,26 @@
+                                                            -*- Autoconf -*-
+
+# PHP skeleton dispatching for Bison.
+
+# Copyright (C) 2007, 2009-2015 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+b4_glr_if(             [b4_complain([%%glr-parser not supported for PHP])])
+b4_nondeterministic_if([b4_complain([%%nondeterministic-parser not supported for PHP])])
+
+m4_define_default([b4_used_skeleton], [b4_pkgdatadir/[lalr1.php]])
+m4_define_default([b4_skeleton], ["b4_basename(b4_used_skeleton)"])
+
+m4_include(b4_used_skeleton)
diff -ruN bison-3.0.4/Makefile.in bison-3.0.4b/Makefile.in
--- bison-3.0.4/Makefile.in	2015-01-23 07:54:26.000000000 -0500
+++ bison-3.0.4b/Makefile.in	2016-02-05 20:39:50.304004500 -0500
@@ -519,7 +519,7 @@
 	src/bison-print.$(OBJEXT) src/bison-print_graph.$(OBJEXT) \
 	src/bison-reader.$(OBJEXT) src/bison-reduce.$(OBJEXT) \
 	src/bison-relation.$(OBJEXT) src/bison-scan-code-c.$(OBJEXT) \
-	src/bison-scan-gram-c.$(OBJEXT) \
+	src/bison-scan-php-c.$(OBJEXT) src/bison-scan-gram-c.$(OBJEXT) \
 	src/bison-scan-skel-c.$(OBJEXT) src/bison-state.$(OBJEXT) \
 	src/bison-symlist.$(OBJEXT) src/bison-symtab.$(OBJEXT) \
 	src/bison-tables.$(OBJEXT) src/bison-uniqstr.$(OBJEXT)
@@ -887,7 +887,7 @@
 	build-aux/config.sub build-aux/depcomp build-aux/install-sh \
 	build-aux/mdate-sh build-aux/missing build-aux/texinfo.tex \
 	build-aux/ylwrap src/parse-gram.c src/parse-gram.h \
-	src/scan-code.c src/scan-gram.c src/scan-skel.c
+	src/scan-code.c src/scan-gram.c src/scan-php.c src/scan-skel.c
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
 top_distdir = $(distdir)
@@ -2258,7 +2258,7 @@
 	lib/sys/wait.h lib/time.h lib/unistd.h \
 	$(LIBUNISTRING_UNITYPES_H) $(LIBUNISTRING_UNIWIDTH_H) \
 	lib/wchar.h lib/wctype.h src/parse-gram.c src/parse-gram.h \
-	src/scan-code.c src/scan-gram.c src/scan-skel.c \
+	src/scan-code.c src/scan-php.c src/scan-gram.c src/scan-skel.c \
 	$(top_srcdir)/.version
 CLEANFILES = doc/refcard.pdf $(FIGS_GV:.gv=.eps) $(FIGS_GV:.gv=.pdf) \
 	$(FIGS_GV:.gv=.png) doc/Doxyfile $(extracted) \
@@ -2562,6 +2562,7 @@
   src/relation.h                                \
   src/scan-code-c.c                             \
   src/scan-code.h                               \
+  src/scan-php-c.c                              \
   src/scan-gram-c.c                             \
   src/scan-gram.h                               \
   src/scan-skel-c.c                             \
@@ -2580,6 +2581,7 @@
 
 EXTRA_src_bison_SOURCES = \
   src/scan-code.l                               \
+  src/scan-php.l                                \
   src/scan-gram.l                               \
   src/scan-skel.l
 
@@ -3186,6 +3188,8 @@
 	src/$(DEPDIR)/$(am__dirstamp)
 src/bison-scan-code-c.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/bison-scan-php-c.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 src/bison-scan-gram-c.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
 src/bison-scan-skel-c.$(OBJEXT): src/$(am__dirstamp) \
@@ -3202,6 +3206,8 @@
 	src/$(DEPDIR)/$(am__dirstamp)
 src/bison-scan-code.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
+src/bison-scan-php.$(OBJEXT): src/$(am__dirstamp) \
+	src/$(DEPDIR)/$(am__dirstamp)
 src/bison-scan-gram.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
 src/bison-scan-skel.$(OBJEXT): src/$(am__dirstamp) \
@@ -3449,6 +3455,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bison-scan-code.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bison-scan-gram-c.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bison-scan-gram.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bison-scan-php-c.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bison-scan-php.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bison-scan-skel-c.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bison-scan-skel.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/bison-state.Po@am__quote@
@@ -3907,6 +3915,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -c -o src/bison-scan-code-c.obj `if test -f 'src/scan-code-c.c'; then $(CYGPATH_W) 'src/scan-code-c.c'; else $(CYGPATH_W) '$(srcdir)/src/scan-code-c.c'; fi`
 
+src/bison-scan-php-c.o: src/scan-php-c.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -MT src/bison-scan-php-c.o -MD -MP -MF src/$(DEPDIR)/bison-scan-php-c.Tpo -c -o src/bison-scan-php-c.o `test -f 'src/scan-php-c.c' || echo '$(srcdir)/'`src/scan-php-c.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bison-scan-php-c.Tpo src/$(DEPDIR)/bison-scan-php-c.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/scan-php-c.c' object='src/bison-scan-php-c.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -c -o src/bison-scan-php-c.o `test -f 'src/scan-php-c.c' || echo '$(srcdir)/'`src/scan-php-c.c
+
+src/bison-scan-php-c.obj: src/scan-php-c.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -MT src/bison-scan-php-c.obj -MD -MP -MF src/$(DEPDIR)/bison-scan-php-c.Tpo -c -o src/bison-scan-php-c.obj `if test -f 'src/scan-php-c.c'; then $(CYGPATH_W) 'src/scan-php-c.c'; else $(CYGPATH_W) '$(srcdir)/src/scan-php-c.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bison-scan-php-c.Tpo src/$(DEPDIR)/bison-scan-php-c.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/scan-php-c.c' object='src/bison-scan-php-c.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -c -o src/bison-scan-php-c.obj `if test -f 'src/scan-php-c.c'; then $(CYGPATH_W) 'src/scan-php-c.c'; else $(CYGPATH_W) '$(srcdir)/src/scan-php-c.c'; fi`
+
 src/bison-scan-gram-c.o: src/scan-gram-c.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -MT src/bison-scan-gram-c.o -MD -MP -MF src/$(DEPDIR)/bison-scan-gram-c.Tpo -c -o src/bison-scan-gram-c.o `test -f 'src/scan-gram-c.c' || echo '$(srcdir)/'`src/scan-gram-c.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bison-scan-gram-c.Tpo src/$(DEPDIR)/bison-scan-gram-c.Po
@@ -4019,6 +4041,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -c -o src/bison-scan-code.obj `if test -f 'src/scan-code.c'; then $(CYGPATH_W) 'src/scan-code.c'; else $(CYGPATH_W) '$(srcdir)/src/scan-code.c'; fi`
 
+src/bison-scan-php.o: src/scan-php.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -MT src/bison-scan-php.o -MD -MP -MF src/$(DEPDIR)/bison-scan-php.Tpo -c -o src/bison-scan-php.o `test -f 'src/scan-php.c' || echo '$(srcdir)/'`src/scan-php.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bison-scan-php.Tpo src/$(DEPDIR)/bison-scan-php.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/scan-php.c' object='src/bison-scan-php.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -c -o src/bison-scan-php.o `test -f 'src/scan-php.c' || echo '$(srcdir)/'`src/scan-php.c
+
+src/bison-scan-php.obj: src/scan-php.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -MT src/bison-scan-php.obj -MD -MP -MF src/$(DEPDIR)/bison-scan-php.Tpo -c -o src/bison-scan-php.obj `if test -f 'src/scan-php.c'; then $(CYGPATH_W) 'src/scan-php.c'; else $(CYGPATH_W) '$(srcdir)/src/scan-php.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bison-scan-php.Tpo src/$(DEPDIR)/bison-scan-php.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='src/scan-php.c' object='src/bison-scan-php.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -c -o src/bison-scan-php.obj `if test -f 'src/scan-php.c'; then $(CYGPATH_W) 'src/scan-php.c'; else $(CYGPATH_W) '$(srcdir)/src/scan-php.c'; fi`
+
 src/bison-scan-gram.o: src/scan-gram.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(src_bison_CFLAGS) $(CFLAGS) -MT src/bison-scan-gram.o -MD -MP -MF src/$(DEPDIR)/bison-scan-gram.Tpo -c -o src/bison-scan-gram.o `test -f 'src/scan-gram.c' || echo '$(srcdir)/'`src/scan-gram.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) src/$(DEPDIR)/bison-scan-gram.Tpo src/$(DEPDIR)/bison-scan-gram.Po
@@ -5043,6 +5079,7 @@
 	-rm -f src/parse-gram.h
 	-rm -f src/scan-code.c
 	-rm -f src/scan-gram.c
+	-rm -f src/scan-php.c
 	-rm -f src/scan-skel.c
 	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
 	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
diff -ruN bison-3.0.4/src/getargs.c bison-3.0.4b/src/getargs.c
--- bison-3.0.4/src/getargs.c	2015-01-16 09:47:42.000000000 -0500
+++ bison-3.0.4b/src/getargs.c	2015-12-30 20:55:31.413650200 -0500
@@ -50,11 +50,17 @@
 int report_flag = report_none;
 int trace_flag = trace_none;
 
+extern char const *
+php_translate_action (code_props *self, int sc_context);
+extern char const *
+c_translate_action (code_props *self, int sc_context);
+
 static struct bison_language const valid_languages[] = {
-  { "c", "c-skel.m4", ".c", ".h", true },
-  { "c++", "c++-skel.m4", ".cc", ".hh", true },
-  { "java", "java-skel.m4", ".java", ".java", false },
-  { "", "", "", "", false }
+  { "c", "c-skel.m4", ".c", ".h", true, &c_translate_action },
+  { "c++", "c++-skel.m4", ".cc", ".hh", true, &c_translate_action },
+  { "java", "java-skel.m4", ".java", ".java", false, &c_translate_action },
+  { "php", "php-skel.m4", ".php", ".php", false, &php_translate_action },
+  { "", "", "", "", false, NULL }
 };
 
 int skeleton_prio = default_prio;
diff -ruN bison-3.0.4/src/getargs.h bison-3.0.4b/src/getargs.h
--- bison-3.0.4/src/getargs.h	2015-01-16 09:47:42.000000000 -0500
+++ bison-3.0.4b/src/getargs.h	2015-12-30 20:48:32.693314800 -0500
@@ -22,6 +22,7 @@
 # define GETARGS_H_
 
 # include "location.h"
+# include "scan-code.h"
 
 enum { command_line_prio, grammar_prio, default_prio };
 
@@ -63,6 +64,7 @@
   char src_extension[sizeof ".java"];
   char header_extension[sizeof ".java"];
   bool add_tab;
+  char const * (*translator)(code_props *self, int sc_context);
 };
 
 extern int language_prio;
diff -ruN bison-3.0.4/src/local.mk bison-3.0.4b/src/local.mk
--- bison-3.0.4/src/local.mk	2015-01-16 09:47:42.000000000 -0500
+++ bison-3.0.4b/src/local.mk	2016-02-05 20:08:02.338674100 -0500
@@ -78,6 +78,7 @@
   src/relation.h                                \
   src/scan-code-c.c                             \
   src/scan-code.h                               \
+  src/scan-php-c.c                              \
   src/scan-gram-c.c                             \
   src/scan-gram.h                               \
   src/scan-skel-c.c                             \
@@ -96,6 +97,7 @@
 
 EXTRA_src_bison_SOURCES =                       \
   src/scan-code.l                               \
+  src/scan-php.l                                \
   src/scan-gram.l                               \
   src/scan-skel.l
 
@@ -103,6 +105,7 @@
   src/parse-gram.c                              \
   src/parse-gram.h                              \
   src/scan-code.c                               \
+  src/scan-php.c                                \
   src/scan-gram.c                               \
   src/scan-skel.c
 
diff -ruN bison-3.0.4/src/parse-gram.c bison-3.0.4b/src/parse-gram.c
--- bison-3.0.4/src/parse-gram.c	2015-01-23 05:28:31.000000000 -0500
+++ bison-3.0.4b/src/parse-gram.c	2015-12-23 21:10:11.128700900 -0500
@@ -1,4 +1,4 @@
-/* A Bison parser, made by GNU Bison 3.0.2.13-975bb-dirty.  */
+/* A Bison parser, made by GNU Bison 3.0.4.  */
 
 /* Bison implementation for Yacc-like parsers in C
 
@@ -44,7 +44,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "3.0.2.13-975bb-dirty"
+#define YYBISON_VERSION "3.0.4"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -97,7 +97,7 @@
 #endif
 
 /* In a future release of Bison, this section will be replaced
-   by #include "src/parse-gram.h".  */
+   by #include "y.tab.h".  */
 #ifndef YY_GRAM_SRC_PARSE_GRAM_H_INCLUDED
 # define YY_GRAM_SRC_PARSE_GRAM_H_INCLUDED
 /* Debug traces.  */
@@ -120,7 +120,7 @@
 
   #include "symlist.h"
   #include "symtab.h"
-#line 221 "src/parse-gram.y" /* yacc.c:355  */
+#line 222 "src/parse-gram.y" /* yacc.c:355  */
 
   typedef enum
   {
@@ -129,7 +129,7 @@
     param_parse  = 1 << 1,
     param_both   = param_lex | param_parse
   } param_type;
-#line 647 "src/parse-gram.y" /* yacc.c:355  */
+#line 650 "src/parse-gram.y" /* yacc.c:355  */
 #include "muscle-tab.h"
 
 #line 136 "src/parse-gram.c" /* yacc.c:355  */
@@ -177,53 +177,112 @@
     PERCENT_VERBOSE = 292,
     PERCENT_YACC = 293,
     BRACED_CODE = 294,
-    BRACED_PREDICATE = 295,
-    BRACKETED_ID = 296,
-    CHAR = 297,
-    EPILOGUE = 298,
-    EQUAL = 299,
-    ID = 300,
-    ID_COLON = 301,
-    PERCENT_PERCENT = 302,
-    PIPE = 303,
-    PROLOGUE = 304,
-    SEMICOLON = 305,
-    TAG = 306,
-    TAG_ANY = 307,
-    TAG_NONE = 308,
-    INT = 309,
-    PERCENT_PARAM = 310,
-    PERCENT_UNION = 311,
-    PERCENT_EMPTY = 312
+    BRACED_PLAIN_CODE = 295,
+    BRACED_PREDICATE = 296,
+    BRACKETED_ID = 297,
+    CHAR = 298,
+    EPILOGUE = 299,
+    EQUAL = 300,
+    ID = 301,
+    ID_COLON = 302,
+    PERCENT_PERCENT = 303,
+    PIPE = 304,
+    PROLOGUE = 305,
+    SEMICOLON = 306,
+    TAG = 307,
+    TAG_ANY = 308,
+    TAG_NONE = 309,
+    INT = 310,
+    PERCENT_PARAM = 311,
+    PERCENT_UNION = 312,
+    PERCENT_EMPTY = 313
   };
 #endif
+/* Tokens.  */
+#define GRAM_EOF 0
+#define STRING 258
+#define PERCENT_TOKEN 259
+#define PERCENT_NTERM 260
+#define PERCENT_TYPE 261
+#define PERCENT_DESTRUCTOR 262
+#define PERCENT_PRINTER 263
+#define PERCENT_LEFT 264
+#define PERCENT_RIGHT 265
+#define PERCENT_NONASSOC 266
+#define PERCENT_PRECEDENCE 267
+#define PERCENT_PREC 268
+#define PERCENT_DPREC 269
+#define PERCENT_MERGE 270
+#define PERCENT_CODE 271
+#define PERCENT_DEFAULT_PREC 272
+#define PERCENT_DEFINE 273
+#define PERCENT_DEFINES 274
+#define PERCENT_ERROR_VERBOSE 275
+#define PERCENT_EXPECT 276
+#define PERCENT_EXPECT_RR 277
+#define PERCENT_FLAG 278
+#define PERCENT_FILE_PREFIX 279
+#define PERCENT_GLR_PARSER 280
+#define PERCENT_INITIAL_ACTION 281
+#define PERCENT_LANGUAGE 282
+#define PERCENT_NAME_PREFIX 283
+#define PERCENT_NO_DEFAULT_PREC 284
+#define PERCENT_NO_LINES 285
+#define PERCENT_NONDETERMINISTIC_PARSER 286
+#define PERCENT_OUTPUT 287
+#define PERCENT_REQUIRE 288
+#define PERCENT_SKELETON 289
+#define PERCENT_START 290
+#define PERCENT_TOKEN_TABLE 291
+#define PERCENT_VERBOSE 292
+#define PERCENT_YACC 293
+#define BRACED_CODE 294
+#define BRACED_PLAIN_CODE 295
+#define BRACED_PREDICATE 296
+#define BRACKETED_ID 297
+#define CHAR 298
+#define EPILOGUE 299
+#define EQUAL 300
+#define ID 301
+#define ID_COLON 302
+#define PERCENT_PERCENT 303
+#define PIPE 304
+#define PROLOGUE 305
+#define SEMICOLON 306
+#define TAG 307
+#define TAG_ANY 308
+#define TAG_NONE 309
+#define INT 310
+#define PERCENT_PARAM 311
+#define PERCENT_UNION 312
+#define PERCENT_EMPTY 313
 
 /* Value type.  */
 #if ! defined GRAM_STYPE && ! defined GRAM_STYPE_IS_DECLARED
 
 union GRAM_STYPE
 {
-#line 182 "src/parse-gram.y" /* yacc.c:355  */
+#line 183 "src/parse-gram.y" /* yacc.c:355  */
 unsigned char character;
-#line 186 "src/parse-gram.y" /* yacc.c:355  */
+#line 187 "src/parse-gram.y" /* yacc.c:355  */
 char *code;
-#line 191 "src/parse-gram.y" /* yacc.c:355  */
+#line 192 "src/parse-gram.y" /* yacc.c:355  */
 uniqstr uniqstr;
-#line 199 "src/parse-gram.y" /* yacc.c:355  */
+#line 200 "src/parse-gram.y" /* yacc.c:355  */
 int integer;
-#line 203 "src/parse-gram.y" /* yacc.c:355  */
+#line 204 "src/parse-gram.y" /* yacc.c:355  */
 symbol *symbol;
-#line 208 "src/parse-gram.y" /* yacc.c:355  */
+#line 209 "src/parse-gram.y" /* yacc.c:355  */
 assoc assoc;
-#line 211 "src/parse-gram.y" /* yacc.c:355  */
+#line 212 "src/parse-gram.y" /* yacc.c:355  */
 symbol_list *list;
-#line 214 "src/parse-gram.y" /* yacc.c:355  */
+#line 215 "src/parse-gram.y" /* yacc.c:355  */
 named_ref *named_ref;
-#line 241 "src/parse-gram.y" /* yacc.c:355  */
+#line 242 "src/parse-gram.y" /* yacc.c:355  */
 param_type param;
-#line 409 "src/parse-gram.y" /* yacc.c:355  */
+#line 410 "src/parse-gram.y" /* yacc.c:355  */
 code_props_type code_type;
-#line 649 "src/parse-gram.y" /* yacc.c:355  */
+#line 652 "src/parse-gram.y" /* yacc.c:355  */
 
   struct
   {
@@ -231,7 +290,7 @@
     muscle_kind kind;
   } value;
 
-#line 235 "src/parse-gram.c" /* yacc.c:355  */
+#line 294 "src/parse-gram.c" /* yacc.c:355  */
 };
 
 typedef union GRAM_STYPE GRAM_STYPE;
@@ -261,7 +320,7 @@
 
 /* Copy the second part of user declarations.  */
 
-#line 265 "src/parse-gram.c" /* yacc.c:358  */
+#line 324 "src/parse-gram.c" /* yacc.c:358  */
 /* Unqualified %code blocks.  */
 #line 33 "src/parse-gram.y" /* yacc.c:359  */
 
@@ -326,7 +385,7 @@
   #define YYTYPE_INT8 int_fast8_t
   #define YYTYPE_UINT16 uint_fast16_t
   #define YYTYPE_UINT8 uint_fast8_t
-#line 231 "src/parse-gram.y" /* yacc.c:359  */
+#line 232 "src/parse-gram.y" /* yacc.c:359  */
 
   /** Add a lex-param and/or a parse-param.
    *
@@ -337,7 +396,7 @@
   static void add_param (param_type type, char *decl, location loc);
   static param_type current_param = param_none;
 
-#line 341 "src/parse-gram.c" /* yacc.c:359  */
+#line 400 "src/parse-gram.c" /* yacc.c:359  */
 
 #ifdef short
 # undef short
@@ -558,21 +617,21 @@
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  3
 /* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   164
+#define YYLAST   168
 
 /* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  58
+#define YYNTOKENS  59
 /* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  37
 /* YYNRULES -- Number of rules.  */
-#define YYNRULES  110
+#define YYNRULES  111
 /* YYNSTATES -- Number of states.  */
-#define YYNSTATES  144
+#define YYNSTATES  146
 
 /* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
    by yylex, with out-of-bounds checking.  */
 #define YYUNDEFTOK  2
-#define YYMAXUTOK   312
+#define YYMAXUTOK   313
 
 #define YYTRANSLATE(YYX)                                                \
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
@@ -612,25 +671,25 @@
       25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
       35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
       45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
-      55,    56,    57
+      55,    56,    57,    58
 };
 
 #if GRAM_DEBUG
   /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_uint16 yyrline[] =
 {
-       0,   264,   264,   273,   274,   278,   279,   285,   289,   294,
-     295,   300,   306,   307,   308,   309,   314,   319,   320,   321,
-     322,   323,   324,   324,   325,   326,   350,   351,   352,   353,
-     357,   358,   367,   368,   369,   373,   385,   389,   393,   401,
-     412,   413,   423,   424,   430,   442,   442,   447,   447,   452,
-     463,   478,   479,   480,   481,   485,   486,   491,   493,   498,
-     503,   513,   515,   520,   521,   525,   526,   530,   531,   532,
-     537,   542,   547,   553,   559,   570,   571,   580,   581,   587,
-     588,   589,   596,   596,   604,   605,   606,   611,   614,   616,
-     618,   620,   622,   624,   626,   631,   632,   642,   643,   668,
-     669,   670,   671,   683,   685,   694,   699,   700,   705,   713,
-     714
+       0,   265,   265,   274,   275,   279,   280,   286,   290,   295,
+     296,   301,   307,   308,   309,   310,   315,   320,   321,   322,
+     323,   324,   325,   325,   326,   327,   351,   352,   353,   354,
+     358,   359,   368,   369,   370,   374,   386,   390,   394,   402,
+     413,   414,   424,   425,   431,   443,   443,   448,   448,   453,
+     464,   479,   480,   481,   482,   486,   487,   492,   494,   499,
+     504,   514,   516,   521,   522,   526,   527,   531,   532,   533,
+     538,   543,   548,   554,   560,   571,   572,   581,   582,   588,
+     589,   590,   597,   597,   605,   606,   607,   612,   615,   617,
+     619,   621,   623,   625,   627,   629,   634,   635,   645,   646,
+     671,   672,   673,   674,   686,   688,   697,   702,   703,   708,
+     716,   717
 };
 #endif
 
@@ -649,18 +708,19 @@
   "\"%name-prefix\"", "\"%no-default-prec\"", "\"%no-lines\"",
   "\"%nondeterministic-parser\"", "\"%output\"", "\"%require\"",
   "\"%skeleton\"", "\"%start\"", "\"%token-table\"", "\"%verbose\"",
-  "\"%yacc\"", "\"{...}\"", "\"%?{...}\"", "\"[identifier]\"", "\"char\"",
-  "\"epilogue\"", "\"=\"", "\"identifier\"", "\"identifier:\"", "\"%%\"",
-  "\"|\"", "\"%{...%}\"", "\";\"", "\"<tag>\"", "\"<*>\"", "\"<>\"",
-  "\"integer\"", "\"%param\"", "\"%union\"", "\"%empty\"", "$accept",
-  "input", "prologue_declarations", "prologue_declaration", "$@1",
-  "params", "grammar_declaration", "code_props_type", "union_name",
-  "symbol_declaration", "$@2", "$@3", "precedence_declaration",
-  "precedence_declarator", "tag.opt", "symbols.prec", "symbol.prec",
-  "symbols.1", "generic_symlist", "generic_symlist_item", "tag",
-  "symbol_def", "symbol_defs.1", "grammar", "rules_or_grammar_declaration",
-  "rules", "$@4", "rhses.1", "rhs", "named_ref.opt", "variable", "value",
-  "id", "id_colon", "symbol", "string_as_id", "epilogue.opt", YY_NULLPTR
+  "\"%yacc\"", "\"{...}\"", "\"%!{...}\"", "\"%?{...}\"",
+  "\"[identifier]\"", "\"char\"", "\"epilogue\"", "\"=\"",
+  "\"identifier\"", "\"identifier:\"", "\"%%\"", "\"|\"", "\"%{...%}\"",
+  "\";\"", "\"<tag>\"", "\"<*>\"", "\"<>\"", "\"integer\"", "\"%param\"",
+  "\"%union\"", "\"%empty\"", "$accept", "input", "prologue_declarations",
+  "prologue_declaration", "$@1", "params", "grammar_declaration",
+  "code_props_type", "union_name", "symbol_declaration", "$@2", "$@3",
+  "precedence_declaration", "precedence_declarator", "tag.opt",
+  "symbols.prec", "symbol.prec", "symbols.1", "generic_symlist",
+  "generic_symlist_item", "tag", "symbol_def", "symbol_defs.1", "grammar",
+  "rules_or_grammar_declaration", "rules", "$@4", "rhses.1", "rhs",
+  "named_ref.opt", "variable", "value", "id", "id_colon", "symbol",
+  "string_as_id", "epilogue.opt", YY_NULLPTR
 };
 #endif
 
@@ -674,16 +734,16 @@
      275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
      285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
      295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
-     305,   306,   307,   308,   309,   310,   311,   312
+     305,   306,   307,   308,   309,   310,   311,   312,   313
 };
 # endif
 
-#define YYPACT_NINF -113
+#define YYPACT_NINF -109
 
 #define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-113)))
+  (!!((Yystate) == (-109)))
 
-#define YYTABLE_NINF -110
+#define YYTABLE_NINF -111
 
 #define yytable_value_is_error(Yytable_value) \
   0
@@ -692,21 +752,21 @@
      STATE-NUM.  */
 static const yytype_int8 yypact[] =
 {
-    -113,    16,   108,  -113,  -113,  -113,   -27,  -113,  -113,  -113,
-    -113,  -113,  -113,   -24,  -113,    23,    24,  -113,   -21,   -15,
-    -113,    29,  -113,     3,    38,    42,  -113,  -113,  -113,    44,
-      47,    71,    31,  -113,  -113,  -113,    55,  -113,  -113,  -113,
-      30,  -113,  -113,    39,  -113,  -113,    26,   -22,   -22,    31,
-    -113,    48,  -113,  -113,     1,  -113,  -113,  -113,  -113,  -113,
-    -113,  -113,  -113,  -113,  -113,  -113,  -113,  -113,  -113,  -113,
-    -113,    45,  -113,    50,     2,  -113,  -113,    57,    49,  -113,
-      52,    41,  -113,    31,  -113,  -113,   -22,    -2,   -22,    31,
-    -113,  -113,  -113,  -113,  -113,  -113,  -113,  -113,    46,  -113,
-    -113,  -113,  -113,  -113,    63,  -113,  -113,  -113,  -113,    41,
-    -113,  -113,  -113,    31,  -113,    51,  -113,   100,  -113,  -113,
-    -113,  -113,  -113,  -113,  -113,  -113,  -113,   -20,    40,  -113,
-    -113,    31,    53,    58,    57,  -113,  -113,    57,    40,  -113,
-    -113,  -113,  -113,  -113
+    -109,    16,   111,  -109,  -109,  -109,   -51,  -109,  -109,  -109,
+    -109,  -109,  -109,   -24,  -109,    25,    18,  -109,   -31,   -30,
+    -109,    30,  -109,     4,    37,    42,  -109,  -109,  -109,    43,
+      44,    45,    29,  -109,  -109,  -109,    57,  -109,  -109,  -109,
+       9,  -109,  -109,    21,  -109,  -109,    24,   -23,   -23,    29,
+    -109,    49,  -109,  -109,    31,  -109,  -109,  -109,  -109,  -109,
+    -109,  -109,  -109,  -109,  -109,  -109,  -109,  -109,  -109,  -109,
+    -109,    32,  -109,    38,     2,  -109,  -109,    48,    52,  -109,
+      59,    41,  -109,    29,  -109,  -109,   -23,     1,   -23,    29,
+    -109,  -109,  -109,  -109,  -109,  -109,  -109,  -109,    56,  -109,
+    -109,  -109,  -109,  -109,    62,  -109,  -109,  -109,  -109,    41,
+    -109,  -109,  -109,    29,  -109,    47,  -109,   100,  -109,  -109,
+    -109,  -109,  -109,  -109,  -109,  -109,  -109,   -13,    39,  -109,
+    -109,    29,    50,    54,    48,    48,  -109,  -109,    48,    39,
+    -109,  -109,  -109,  -109,  -109,  -109
 };
 
   /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
@@ -719,25 +779,25 @@
        7,     0,    15,     0,     0,     0,    37,    19,    20,     0,
        0,     0,     0,    26,    27,    28,     0,     6,    29,    22,
       42,     4,     5,     0,    33,    32,    55,     0,     0,     0,
-      38,     0,    98,    97,    99,    10,    12,    13,    14,    16,
-      17,    18,    21,    24,    25,   108,   104,   103,   106,    34,
-     107,     0,   105,     0,     0,    77,    79,    95,     0,    43,
+      38,     0,    99,    98,   100,    10,    12,    13,    14,    16,
+      17,    18,    21,    24,    25,   109,   105,   104,   107,    34,
+     108,     0,   106,     0,     0,    77,    79,    96,     0,    43,
        0,     0,    56,     0,    70,    75,    48,    71,    46,    49,
-      61,    39,   101,   102,   100,     8,    81,    80,     0,    78,
-       2,    96,    82,    31,    23,    44,    67,    68,    69,    35,
+      61,    39,   102,   103,   101,     8,    81,    80,     0,    78,
+       2,    97,    82,    31,    23,    44,    67,    68,    69,    35,
       63,    66,    65,    50,    57,    59,    76,    72,    73,    62,
-     110,    87,    30,    64,    58,    60,    74,    83,    84,    87,
-      86,     0,     0,     0,    95,    90,    91,    95,    85,    92,
-      93,    94,    89,    88
+     111,    87,    30,    64,    58,    60,    74,    83,    84,    87,
+      86,     0,     0,     0,    96,    96,    91,    92,    96,    85,
+      93,    94,    95,    89,    90,    88
 };
 
   /* YYPGOTO[NTERM-NUM].  */
 static const yytype_int8 yypgoto[] =
 {
-    -113,  -113,  -113,  -113,  -113,  -113,   102,  -113,  -113,  -113,
-    -113,  -113,  -113,  -113,  -113,  -113,     8,  -113,  -113,    13,
-    -113,   -50,    75,  -113,    73,  -113,  -113,  -113,    19,  -112,
-    -113,  -113,    22,  -113,   -32,   -82,  -113
+    -109,  -109,  -109,  -109,  -109,  -109,   106,  -109,  -109,  -109,
+    -109,  -109,  -109,  -109,  -109,  -109,    -4,  -109,  -109,    15,
+    -109,   -47,    65,  -109,    36,  -109,  -109,  -109,    -3,  -108,
+    -109,  -109,    64,  -109,   -32,   -82,  -109
 };
 
   /* YYDEFGOTO[NTERM-NUM].  */
@@ -754,82 +814,82 @@
      number is the opposite.  If YYTABLE_NINF, syntax error.  */
 static const yytype_int16 yytable[] =
 {
-      69,    65,  -109,    71,    92,   118,     4,     5,     6,     7,
+      69,    49,  -110,    71,    65,   118,     4,     5,     6,     7,
        8,     9,    10,    11,    12,    50,     3,    90,    13,    14,
-      66,    51,   142,    67,    49,   143,    52,    55,   129,    84,
-     130,    26,    58,    56,    65,   126,   116,    32,   116,    57,
-      93,    60,    59,    65,    65,    61,    94,    62,    72,    98,
-      63,   115,   117,   131,   132,   133,    71,   119,    40,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    53,    87,
-      87,    13,    14,    66,    64,    79,    67,    82,    81,   134,
-     135,   115,    66,    66,    26,    67,    67,    91,   103,   120,
-      32,   105,   106,   107,   108,    96,   137,   136,   101,   139,
-      97,    72,   122,    65,    42,   125,   137,   140,    87,   141,
-      87,    40,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,   124,   123,    88,    13,    14,    15,    16,    17,    18,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    35,    99,   138,     0,
-       0,     0,     0,     0,     0,    36,     0,    37,    38,     0,
-       0,     0,     0,    39,    40
+      66,    55,    51,    67,    56,    57,   143,   144,    52,    84,
+     145,    26,    65,    58,    92,   126,   129,    32,   130,   116,
+      60,   116,    65,    59,    65,    61,    62,    63,    64,    72,
+      98,   115,   131,   132,   133,    79,   117,   119,    71,    40,
+      81,     4,     5,     6,     7,     8,     9,    10,    11,    12,
+      93,    53,    66,    13,    14,    67,    82,    94,   134,   135,
+     136,   115,    66,    96,    66,    67,    26,    67,    91,    97,
+     101,   103,    32,   106,   107,   108,   138,   137,   105,   140,
+     120,   122,   125,    65,    72,   141,   142,   138,    42,   124,
+      99,    87,    87,    88,    40,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,   123,     0,   139,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
+      87,     0,    87,     0,     0,     0,     0,     0,     0,    36,
+       0,    37,    38,     0,     0,     0,     0,    39,    40
 };
 
 static const yytype_int16 yycheck[] =
 {
-      32,     3,     0,     1,     3,    87,     4,     5,     6,     7,
+      32,    52,     0,     1,     3,    87,     4,     5,     6,     7,
        8,     9,    10,    11,    12,    39,     0,    49,    16,    17,
-      42,    45,   134,    45,    51,   137,     3,     3,    48,    51,
-      50,    29,     3,    54,     3,   117,    86,    35,    88,    54,
-      39,     3,    39,     3,     3,     3,    45,     3,    46,    47,
-       3,    83,    54,    13,    14,    15,     1,    89,    56,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    45,    47,
-      48,    16,    17,    42,     3,    45,    45,    51,    39,    39,
-      40,   113,    42,    42,    29,    45,    45,    39,    39,    43,
-      35,    39,    51,    52,    53,    50,   128,    57,    41,   131,
-      50,    46,    39,     3,     2,    54,   138,    54,    86,    51,
-      88,    56,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,   113,   109,    48,    16,    17,    18,    19,    20,    21,
-      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
-      32,    33,    34,    35,    36,    37,    38,    74,   129,    -1,
-      -1,    -1,    -1,    -1,    -1,    47,    -1,    49,    50,    -1,
-      -1,    -1,    -1,    55,    56
+      43,     3,    46,    46,    55,    55,   134,   135,     3,    52,
+     138,    29,     3,     3,     3,   117,    49,    35,    51,    86,
+       3,    88,     3,    39,     3,     3,     3,     3,     3,    47,
+      48,    83,    13,    14,    15,    46,    55,    89,     1,    57,
+      39,     4,     5,     6,     7,     8,     9,    10,    11,    12,
+      39,    46,    43,    16,    17,    46,    52,    46,    39,    40,
+      41,   113,    43,    51,    43,    46,    29,    46,    39,    51,
+      42,    39,    35,    52,    53,    54,   128,    58,    39,   131,
+      44,    39,    55,     3,    47,    55,    52,   139,     2,   113,
+      74,    47,    48,    48,    57,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,   109,    -1,   129,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      86,    -1,    88,    -1,    -1,    -1,    -1,    -1,    -1,    48,
+      -1,    50,    51,    -1,    -1,    -1,    -1,    56,    57
 };
 
   /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
      symbol of state STATE-NUM.  */
 static const yytype_uint8 yystos[] =
 {
-       0,    59,    60,     0,     4,     5,     6,     7,     8,     9,
+       0,    60,    61,     0,     4,     5,     6,     7,     8,     9,
       10,    11,    12,    16,    17,    18,    19,    20,    21,    22,
       23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
-      33,    34,    35,    36,    37,    38,    47,    49,    50,    55,
-      56,    61,    64,    65,    67,    70,    71,    69,    68,    51,
-      39,    45,     3,    45,    88,     3,    54,    54,     3,    39,
-       3,     3,     3,     3,     3,     3,    42,    45,    90,    92,
-      93,     1,    46,    64,    81,    82,    83,    91,    62,    45,
-      66,    39,    51,    72,    51,    79,    80,    90,    80,    75,
-      92,    39,     3,    39,    45,    89,    50,    50,    47,    82,
-      94,    41,    87,    39,    63,    39,    51,    52,    53,    76,
-      77,    78,    92,    73,    74,    92,    79,    54,    93,    92,
-      43,    84,    39,    77,    74,    54,    93,    85,    86,    48,
-      50,    13,    14,    15,    39,    40,    57,    92,    86,    92,
-      54,    51,    87,    87
+      33,    34,    35,    36,    37,    38,    48,    50,    51,    56,
+      57,    62,    65,    66,    68,    71,    72,    70,    69,    52,
+      39,    46,     3,    46,    89,     3,    55,    55,     3,    39,
+       3,     3,     3,     3,     3,     3,    43,    46,    91,    93,
+      94,     1,    47,    65,    82,    83,    84,    92,    63,    46,
+      67,    39,    52,    73,    52,    80,    81,    91,    81,    76,
+      93,    39,     3,    39,    46,    90,    51,    51,    48,    83,
+      95,    42,    88,    39,    64,    39,    52,    53,    54,    77,
+      78,    79,    93,    74,    75,    93,    80,    55,    94,    93,
+      44,    85,    39,    78,    75,    55,    94,    86,    87,    49,
+      51,    13,    14,    15,    39,    40,    41,    58,    93,    87,
+      93,    55,    52,    88,    88,    88
 };
 
   /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
 static const yytype_uint8 yyr1[] =
 {
-       0,    58,    59,    60,    60,    61,    61,    61,    61,    61,
-      61,    61,    61,    61,    61,    61,    61,    61,    61,    61,
-      61,    61,    62,    61,    61,    61,    61,    61,    61,    61,
-      63,    63,    64,    64,    64,    64,    64,    64,    64,    64,
-      65,    65,    66,    66,    64,    68,    67,    69,    67,    67,
-      70,    71,    71,    71,    71,    72,    72,    73,    73,    74,
-      74,    75,    75,    76,    76,    77,    77,    78,    78,    78,
-      79,    79,    79,    79,    79,    80,    80,    81,    81,    82,
-      82,    82,    84,    83,    85,    85,    85,    86,    86,    86,
-      86,    86,    86,    86,    86,    87,    87,    88,    88,    89,
-      89,    89,    89,    90,    90,    91,    92,    92,    93,    94,
-      94
+       0,    59,    60,    61,    61,    62,    62,    62,    62,    62,
+      62,    62,    62,    62,    62,    62,    62,    62,    62,    62,
+      62,    62,    63,    62,    62,    62,    62,    62,    62,    62,
+      64,    64,    65,    65,    65,    65,    65,    65,    65,    65,
+      66,    66,    67,    67,    65,    69,    68,    70,    68,    68,
+      71,    72,    72,    72,    72,    73,    73,    74,    74,    75,
+      75,    76,    76,    77,    77,    78,    78,    79,    79,    79,
+      80,    80,    80,    80,    80,    81,    81,    82,    82,    83,
+      83,    83,    85,    84,    86,    86,    86,    87,    87,    87,
+      87,    87,    87,    87,    87,    87,    88,    88,    89,    89,
+      90,    90,    90,    90,    91,    91,    92,    93,    93,    94,
+      95,    95
 };
 
   /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
@@ -844,9 +904,9 @@
        2,     1,     2,     1,     2,     1,     1,     1,     1,     1,
        1,     1,     2,     2,     3,     1,     2,     1,     2,     1,
        2,     2,     0,     4,     1,     3,     2,     0,     3,     3,
-       2,     2,     3,     3,     3,     0,     1,     1,     1,     0,
-       1,     1,     1,     1,     1,     1,     1,     1,     1,     0,
-       2
+       3,     2,     2,     3,     3,     3,     0,     1,     1,     1,
+       0,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       0,     2
 };
 
 
@@ -1002,79 +1062,85 @@
   switch (yytype)
     {
           case 3: /* "string"  */
-#line 188 "src/parse-gram.y" /* yacc.c:684  */
+#line 189 "src/parse-gram.y" /* yacc.c:684  */
       { fputs (quotearg_style (c_quoting_style, ((*yyvaluep).code)), yyo); }
-#line 1008 "src/parse-gram.c" /* yacc.c:684  */
+#line 1068 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
     case 23: /* "%<flag>"  */
-#line 196 "src/parse-gram.y" /* yacc.c:684  */
+#line 197 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "%%%s", ((*yyvaluep).uniqstr)); }
-#line 1014 "src/parse-gram.c" /* yacc.c:684  */
+#line 1074 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
     case 39: /* "{...}"  */
-#line 189 "src/parse-gram.y" /* yacc.c:684  */
+#line 190 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "{\n%s\n}", ((*yyvaluep).code)); }
-#line 1020 "src/parse-gram.c" /* yacc.c:684  */
+#line 1080 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 40: /* "%?{...}"  */
-#line 189 "src/parse-gram.y" /* yacc.c:684  */
+    case 40: /* "%!{...}"  */
+#line 190 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "{\n%s\n}", ((*yyvaluep).code)); }
-#line 1026 "src/parse-gram.c" /* yacc.c:684  */
+#line 1086 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 41: /* "[identifier]"  */
-#line 194 "src/parse-gram.y" /* yacc.c:684  */
+    case 41: /* "%?{...}"  */
+#line 190 "src/parse-gram.y" /* yacc.c:684  */
+      { fprintf (yyo, "{\n%s\n}", ((*yyvaluep).code)); }
+#line 1092 "src/parse-gram.c" /* yacc.c:684  */
+        break;
+
+    case 42: /* "[identifier]"  */
+#line 195 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "[%s]", ((*yyvaluep).uniqstr)); }
-#line 1032 "src/parse-gram.c" /* yacc.c:684  */
+#line 1098 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 42: /* "char"  */
-#line 184 "src/parse-gram.y" /* yacc.c:684  */
+    case 43: /* "char"  */
+#line 185 "src/parse-gram.y" /* yacc.c:684  */
       { fputs (char_name (((*yyvaluep).character)), yyo); }
-#line 1038 "src/parse-gram.c" /* yacc.c:684  */
+#line 1104 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 43: /* "epilogue"  */
-#line 189 "src/parse-gram.y" /* yacc.c:684  */
+    case 44: /* "epilogue"  */
+#line 190 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "{\n%s\n}", ((*yyvaluep).code)); }
-#line 1044 "src/parse-gram.c" /* yacc.c:684  */
+#line 1110 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 45: /* "identifier"  */
-#line 193 "src/parse-gram.y" /* yacc.c:684  */
+    case 46: /* "identifier"  */
+#line 194 "src/parse-gram.y" /* yacc.c:684  */
       { fputs (((*yyvaluep).uniqstr), yyo); }
-#line 1050 "src/parse-gram.c" /* yacc.c:684  */
+#line 1116 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 46: /* "identifier:"  */
-#line 195 "src/parse-gram.y" /* yacc.c:684  */
+    case 47: /* "identifier:"  */
+#line 196 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "%s:", ((*yyvaluep).uniqstr)); }
-#line 1056 "src/parse-gram.c" /* yacc.c:684  */
+#line 1122 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 49: /* "%{...%}"  */
-#line 189 "src/parse-gram.y" /* yacc.c:684  */
+    case 50: /* "%{...%}"  */
+#line 190 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "{\n%s\n}", ((*yyvaluep).code)); }
-#line 1062 "src/parse-gram.c" /* yacc.c:684  */
+#line 1128 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 51: /* "<tag>"  */
-#line 197 "src/parse-gram.y" /* yacc.c:684  */
+    case 52: /* "<tag>"  */
+#line 198 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "<%s>", ((*yyvaluep).uniqstr)); }
-#line 1068 "src/parse-gram.c" /* yacc.c:684  */
+#line 1134 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 54: /* "integer"  */
-#line 201 "src/parse-gram.y" /* yacc.c:684  */
+    case 55: /* "integer"  */
+#line 202 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "%d", ((*yyvaluep).integer)); }
-#line 1074 "src/parse-gram.c" /* yacc.c:684  */
+#line 1140 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 55: /* "%param"  */
-#line 244 "src/parse-gram.y" /* yacc.c:684  */
+    case 56: /* "%param"  */
+#line 245 "src/parse-gram.y" /* yacc.c:684  */
       {
   switch (((*yyvaluep).param))
     {
@@ -1087,35 +1153,35 @@
       case param_none: aver (false); break;
     }
 }
-#line 1091 "src/parse-gram.c" /* yacc.c:684  */
+#line 1157 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 65: /* code_props_type  */
-#line 410 "src/parse-gram.y" /* yacc.c:684  */
+    case 66: /* code_props_type  */
+#line 411 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "%s", code_props_type_string (((*yyvaluep).code_type))); }
-#line 1097 "src/parse-gram.c" /* yacc.c:684  */
+#line 1163 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 74: /* symbol.prec  */
-#line 205 "src/parse-gram.y" /* yacc.c:684  */
+    case 75: /* symbol.prec  */
+#line 206 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "%s", ((*yyvaluep).symbol)->tag); }
-#line 1103 "src/parse-gram.c" /* yacc.c:684  */
+#line 1169 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 78: /* tag  */
-#line 197 "src/parse-gram.y" /* yacc.c:684  */
+    case 79: /* tag  */
+#line 198 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "<%s>", ((*yyvaluep).uniqstr)); }
-#line 1109 "src/parse-gram.c" /* yacc.c:684  */
+#line 1175 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 88: /* variable  */
-#line 193 "src/parse-gram.y" /* yacc.c:684  */
+    case 89: /* variable  */
+#line 194 "src/parse-gram.y" /* yacc.c:684  */
       { fputs (((*yyvaluep).uniqstr), yyo); }
-#line 1115 "src/parse-gram.c" /* yacc.c:684  */
+#line 1181 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 89: /* value  */
-#line 658 "src/parse-gram.y" /* yacc.c:684  */
+    case 90: /* value  */
+#line 661 "src/parse-gram.y" /* yacc.c:684  */
       {
   switch (((*yyvaluep).value).kind)
     {
@@ -1124,31 +1190,31 @@
     case muscle_string:  fprintf (yyo, "\"%s\"", ((*yyvaluep).value).chars); break;
     }
 }
-#line 1128 "src/parse-gram.c" /* yacc.c:684  */
+#line 1194 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 90: /* id  */
-#line 205 "src/parse-gram.y" /* yacc.c:684  */
+    case 91: /* id  */
+#line 206 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "%s", ((*yyvaluep).symbol)->tag); }
-#line 1134 "src/parse-gram.c" /* yacc.c:684  */
+#line 1200 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 91: /* id_colon  */
-#line 206 "src/parse-gram.y" /* yacc.c:684  */
+    case 92: /* id_colon  */
+#line 207 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "%s:", ((*yyvaluep).symbol)->tag); }
-#line 1140 "src/parse-gram.c" /* yacc.c:684  */
+#line 1206 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 92: /* symbol  */
-#line 205 "src/parse-gram.y" /* yacc.c:684  */
+    case 93: /* symbol  */
+#line 206 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "%s", ((*yyvaluep).symbol)->tag); }
-#line 1146 "src/parse-gram.c" /* yacc.c:684  */
+#line 1212 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
-    case 93: /* string_as_id  */
-#line 205 "src/parse-gram.y" /* yacc.c:684  */
+    case 94: /* string_as_id  */
+#line 206 "src/parse-gram.y" /* yacc.c:684  */
       { fprintf (yyo, "%s", ((*yyvaluep).symbol)->tag); }
-#line 1152 "src/parse-gram.c" /* yacc.c:684  */
+#line 1218 "src/parse-gram.c" /* yacc.c:684  */
         break;
 
 
@@ -1850,7 +1916,7 @@
   boundary_set (&yylloc.end, current_file, 1, 1);
 }
 
-#line 1854 "src/parse-gram.c" /* yacc.c:1429  */
+#line 1920 "src/parse-gram.c" /* yacc.c:1429  */
   yylsp[0] = yylloc;
   goto yysetstate;
 
@@ -2044,143 +2110,143 @@
     switch (yyn)
       {
           case 6:
-#line 280 "src/parse-gram.y" /* yacc.c:1646  */
+#line 281 "src/parse-gram.y" /* yacc.c:1646  */
     {
       muscle_code_grow (union_seen ? "post_prologue" : "pre_prologue",
                         translate_code ((yyvsp[0].code), (yylsp[0]), true), (yylsp[0]));
       code_scanner_last_string_free ();
     }
-#line 2054 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2120 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 7:
-#line 286 "src/parse-gram.y" /* yacc.c:1646  */
+#line 287 "src/parse-gram.y" /* yacc.c:1646  */
     {
       muscle_percent_define_ensure ((yyvsp[0].uniqstr), (yylsp[0]), true);
     }
-#line 2062 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2128 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 8:
-#line 290 "src/parse-gram.y" /* yacc.c:1646  */
+#line 291 "src/parse-gram.y" /* yacc.c:1646  */
     {
       muscle_percent_define_insert ((yyvsp[-1].uniqstr), (yylsp[-1]), (yyvsp[0].value).kind, (yyvsp[0].value).chars,
                                     MUSCLE_PERCENT_DEFINE_GRAMMAR_FILE);
     }
-#line 2071 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2137 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 9:
-#line 294 "src/parse-gram.y" /* yacc.c:1646  */
+#line 295 "src/parse-gram.y" /* yacc.c:1646  */
     { defines_flag = true; }
-#line 2077 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2143 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 10:
-#line 296 "src/parse-gram.y" /* yacc.c:1646  */
+#line 297 "src/parse-gram.y" /* yacc.c:1646  */
     {
       defines_flag = true;
       spec_defines_file = xstrdup ((yyvsp[0].code));
     }
-#line 2086 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2152 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 11:
-#line 301 "src/parse-gram.y" /* yacc.c:1646  */
+#line 302 "src/parse-gram.y" /* yacc.c:1646  */
     {
       muscle_percent_define_insert ("parse.error", (yylsp[0]), muscle_keyword,
                                     "verbose",
                                     MUSCLE_PERCENT_DEFINE_GRAMMAR_FILE);
     }
-#line 2096 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2162 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 12:
-#line 306 "src/parse-gram.y" /* yacc.c:1646  */
+#line 307 "src/parse-gram.y" /* yacc.c:1646  */
     { expected_sr_conflicts = (yyvsp[0].integer); }
-#line 2102 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2168 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 13:
-#line 307 "src/parse-gram.y" /* yacc.c:1646  */
+#line 308 "src/parse-gram.y" /* yacc.c:1646  */
     { expected_rr_conflicts = (yyvsp[0].integer); }
-#line 2108 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2174 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 14:
-#line 308 "src/parse-gram.y" /* yacc.c:1646  */
+#line 309 "src/parse-gram.y" /* yacc.c:1646  */
     { spec_file_prefix = (yyvsp[0].code); }
-#line 2114 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2180 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 15:
-#line 310 "src/parse-gram.y" /* yacc.c:1646  */
+#line 311 "src/parse-gram.y" /* yacc.c:1646  */
     {
       nondeterministic_parser = true;
       glr_parser = true;
     }
-#line 2123 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2189 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 16:
-#line 315 "src/parse-gram.y" /* yacc.c:1646  */
+#line 316 "src/parse-gram.y" /* yacc.c:1646  */
     {
       muscle_code_grow ("initial_action", translate_code ((yyvsp[0].code), (yylsp[0]), false), (yylsp[0]));
       code_scanner_last_string_free ();
     }
-#line 2132 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2198 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 17:
-#line 319 "src/parse-gram.y" /* yacc.c:1646  */
+#line 320 "src/parse-gram.y" /* yacc.c:1646  */
     { language_argmatch ((yyvsp[0].code), grammar_prio, (yylsp[-1])); }
-#line 2138 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2204 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 18:
-#line 320 "src/parse-gram.y" /* yacc.c:1646  */
+#line 321 "src/parse-gram.y" /* yacc.c:1646  */
     { spec_name_prefix = (yyvsp[0].code); }
-#line 2144 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2210 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 19:
-#line 321 "src/parse-gram.y" /* yacc.c:1646  */
+#line 322 "src/parse-gram.y" /* yacc.c:1646  */
     { no_lines_flag = true; }
-#line 2150 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2216 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 20:
-#line 322 "src/parse-gram.y" /* yacc.c:1646  */
+#line 323 "src/parse-gram.y" /* yacc.c:1646  */
     { nondeterministic_parser = true; }
-#line 2156 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2222 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 21:
-#line 323 "src/parse-gram.y" /* yacc.c:1646  */
+#line 324 "src/parse-gram.y" /* yacc.c:1646  */
     { spec_outfile = (yyvsp[0].code); }
-#line 2162 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2228 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 22:
-#line 324 "src/parse-gram.y" /* yacc.c:1646  */
+#line 325 "src/parse-gram.y" /* yacc.c:1646  */
     { current_param = (yyvsp[0].param); }
-#line 2168 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2234 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 23:
-#line 324 "src/parse-gram.y" /* yacc.c:1646  */
+#line 325 "src/parse-gram.y" /* yacc.c:1646  */
     { current_param = param_none; }
-#line 2174 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2240 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 24:
-#line 325 "src/parse-gram.y" /* yacc.c:1646  */
+#line 326 "src/parse-gram.y" /* yacc.c:1646  */
     { version_check (&(yylsp[0]), (yyvsp[0].code)); }
-#line 2180 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2246 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 25:
-#line 327 "src/parse-gram.y" /* yacc.c:1646  */
+#line 328 "src/parse-gram.y" /* yacc.c:1646  */
     {
       char const *skeleton_user = (yyvsp[0].code);
       if (strchr (skeleton_user, '/'))
@@ -2204,49 +2270,49 @@
         }
       skeleton_arg (skeleton_user, grammar_prio, (yylsp[-1]));
     }
-#line 2208 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2274 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 26:
-#line 350 "src/parse-gram.y" /* yacc.c:1646  */
+#line 351 "src/parse-gram.y" /* yacc.c:1646  */
     { token_table_flag = true; }
-#line 2214 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2280 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 27:
-#line 351 "src/parse-gram.y" /* yacc.c:1646  */
+#line 352 "src/parse-gram.y" /* yacc.c:1646  */
     { report_flag |= report_states; }
-#line 2220 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2286 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 28:
-#line 352 "src/parse-gram.y" /* yacc.c:1646  */
+#line 353 "src/parse-gram.y" /* yacc.c:1646  */
     { yacc_flag = true; }
-#line 2226 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2292 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 30:
-#line 357 "src/parse-gram.y" /* yacc.c:1646  */
+#line 358 "src/parse-gram.y" /* yacc.c:1646  */
     { add_param (current_param, (yyvsp[0].code), (yylsp[0])); }
-#line 2232 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2298 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 31:
-#line 358 "src/parse-gram.y" /* yacc.c:1646  */
+#line 359 "src/parse-gram.y" /* yacc.c:1646  */
     { add_param (current_param, (yyvsp[0].code), (yylsp[0])); }
-#line 2238 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2304 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 34:
-#line 370 "src/parse-gram.y" /* yacc.c:1646  */
+#line 371 "src/parse-gram.y" /* yacc.c:1646  */
     {
       grammar_start_symbol_set ((yyvsp[0].symbol), (yylsp[0]));
     }
-#line 2246 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2312 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 35:
-#line 374 "src/parse-gram.y" /* yacc.c:1646  */
+#line 375 "src/parse-gram.y" /* yacc.c:1646  */
     {
       code_props code;
       code_props_symbol_action_init (&code, (yyvsp[-1].code), (yylsp[-1]));
@@ -2258,27 +2324,27 @@
         symbol_list_free ((yyvsp[0].list));
       }
     }
-#line 2262 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2328 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 36:
-#line 386 "src/parse-gram.y" /* yacc.c:1646  */
+#line 387 "src/parse-gram.y" /* yacc.c:1646  */
     {
       default_prec = true;
     }
-#line 2270 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2336 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 37:
-#line 390 "src/parse-gram.y" /* yacc.c:1646  */
+#line 391 "src/parse-gram.y" /* yacc.c:1646  */
     {
       default_prec = false;
     }
-#line 2278 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2344 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 38:
-#line 394 "src/parse-gram.y" /* yacc.c:1646  */
+#line 395 "src/parse-gram.y" /* yacc.c:1646  */
     {
       /* Do not invoke muscle_percent_code_grow here since it invokes
          muscle_user_name_list_grow.  */
@@ -2286,86 +2352,86 @@
                         translate_code_braceless ((yyvsp[0].code), (yylsp[0])), (yylsp[0]));
       code_scanner_last_string_free ();
     }
-#line 2290 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2356 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 39:
-#line 402 "src/parse-gram.y" /* yacc.c:1646  */
+#line 403 "src/parse-gram.y" /* yacc.c:1646  */
     {
       muscle_percent_code_grow ((yyvsp[-1].uniqstr), (yylsp[-1]), translate_code_braceless ((yyvsp[0].code), (yylsp[0])), (yylsp[0]));
       code_scanner_last_string_free ();
     }
-#line 2299 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2365 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 40:
-#line 412 "src/parse-gram.y" /* yacc.c:1646  */
+#line 413 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.code_type) = destructor; }
-#line 2305 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2371 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 41:
-#line 413 "src/parse-gram.y" /* yacc.c:1646  */
+#line 414 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.code_type) = printer; }
-#line 2311 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2377 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 42:
-#line 423 "src/parse-gram.y" /* yacc.c:1646  */
+#line 424 "src/parse-gram.y" /* yacc.c:1646  */
     {}
-#line 2317 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2383 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 43:
-#line 424 "src/parse-gram.y" /* yacc.c:1646  */
+#line 425 "src/parse-gram.y" /* yacc.c:1646  */
     { muscle_percent_define_insert ("api.value.union.name",
                                          (yylsp[0]), muscle_keyword, (yyvsp[0].uniqstr),
                                          MUSCLE_PERCENT_DEFINE_GRAMMAR_FILE); }
-#line 2325 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2391 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 44:
-#line 431 "src/parse-gram.y" /* yacc.c:1646  */
+#line 432 "src/parse-gram.y" /* yacc.c:1646  */
     {
       union_seen = true;
       muscle_code_grow ("union_members", translate_code_braceless ((yyvsp[0].code), (yylsp[0])), (yylsp[0]));
       code_scanner_last_string_free ();
     }
-#line 2335 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2401 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 45:
-#line 442 "src/parse-gram.y" /* yacc.c:1646  */
+#line 443 "src/parse-gram.y" /* yacc.c:1646  */
     { current_class = nterm_sym; }
-#line 2341 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2407 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 46:
-#line 443 "src/parse-gram.y" /* yacc.c:1646  */
+#line 444 "src/parse-gram.y" /* yacc.c:1646  */
     {
       current_class = unknown_sym;
       current_type = NULL;
     }
-#line 2350 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2416 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 47:
-#line 447 "src/parse-gram.y" /* yacc.c:1646  */
+#line 448 "src/parse-gram.y" /* yacc.c:1646  */
     { current_class = token_sym; }
-#line 2356 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2422 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 48:
-#line 448 "src/parse-gram.y" /* yacc.c:1646  */
+#line 449 "src/parse-gram.y" /* yacc.c:1646  */
     {
       current_class = unknown_sym;
       current_type = NULL;
     }
-#line 2365 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2431 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 49:
-#line 453 "src/parse-gram.y" /* yacc.c:1646  */
+#line 454 "src/parse-gram.y" /* yacc.c:1646  */
     {
       symbol_list *list;
       tag_seen = true;
@@ -2373,11 +2439,11 @@
         symbol_type_set (list->content.sym, (yyvsp[-1].uniqstr), (yylsp[-1]));
       symbol_list_free ((yyvsp[0].list));
     }
-#line 2377 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2443 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 50:
-#line 464 "src/parse-gram.y" /* yacc.c:1646  */
+#line 465 "src/parse-gram.y" /* yacc.c:1646  */
     {
       symbol_list *list;
       ++current_prec;
@@ -2389,341 +2455,347 @@
       symbol_list_free ((yyvsp[0].list));
       current_type = NULL;
     }
-#line 2393 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2459 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 51:
-#line 478 "src/parse-gram.y" /* yacc.c:1646  */
+#line 479 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.assoc) = left_assoc; }
-#line 2399 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2465 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 52:
-#line 479 "src/parse-gram.y" /* yacc.c:1646  */
+#line 480 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.assoc) = right_assoc; }
-#line 2405 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2471 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 53:
-#line 480 "src/parse-gram.y" /* yacc.c:1646  */
+#line 481 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.assoc) = non_assoc; }
-#line 2411 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2477 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 54:
-#line 481 "src/parse-gram.y" /* yacc.c:1646  */
+#line 482 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.assoc) = precedence_assoc; }
-#line 2417 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2483 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 55:
-#line 485 "src/parse-gram.y" /* yacc.c:1646  */
+#line 486 "src/parse-gram.y" /* yacc.c:1646  */
     { current_type = NULL; }
-#line 2423 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2489 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 56:
-#line 486 "src/parse-gram.y" /* yacc.c:1646  */
+#line 487 "src/parse-gram.y" /* yacc.c:1646  */
     { current_type = (yyvsp[0].uniqstr); tag_seen = true; }
-#line 2429 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2495 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 57:
-#line 492 "src/parse-gram.y" /* yacc.c:1646  */
+#line 493 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.list) = symbol_list_sym_new ((yyvsp[0].symbol), (yylsp[0])); }
-#line 2435 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2501 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 58:
-#line 494 "src/parse-gram.y" /* yacc.c:1646  */
+#line 495 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.list) = symbol_list_append ((yyvsp[-1].list), symbol_list_sym_new ((yyvsp[0].symbol), (yylsp[0]))); }
-#line 2441 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2507 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 59:
-#line 499 "src/parse-gram.y" /* yacc.c:1646  */
+#line 500 "src/parse-gram.y" /* yacc.c:1646  */
     {
       (yyval.symbol) = (yyvsp[0].symbol);
       symbol_class_set ((yyvsp[0].symbol), token_sym, (yylsp[0]), false);
     }
-#line 2450 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2516 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 60:
-#line 504 "src/parse-gram.y" /* yacc.c:1646  */
+#line 505 "src/parse-gram.y" /* yacc.c:1646  */
     {
       (yyval.symbol) = (yyvsp[-1].symbol);
       symbol_user_token_number_set ((yyvsp[-1].symbol), (yyvsp[0].integer), (yylsp[0]));
       symbol_class_set ((yyvsp[-1].symbol), token_sym, (yylsp[-1]), false);
     }
-#line 2460 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2526 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 61:
-#line 514 "src/parse-gram.y" /* yacc.c:1646  */
+#line 515 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.list) = symbol_list_sym_new ((yyvsp[0].symbol), (yylsp[0])); }
-#line 2466 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2532 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 62:
-#line 516 "src/parse-gram.y" /* yacc.c:1646  */
+#line 517 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.list) = symbol_list_append ((yyvsp[-1].list), symbol_list_sym_new ((yyvsp[0].symbol), (yylsp[0]))); }
-#line 2472 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2538 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 63:
-#line 520 "src/parse-gram.y" /* yacc.c:1646  */
+#line 521 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.list) = (yyvsp[0].list); }
-#line 2478 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2544 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 64:
-#line 521 "src/parse-gram.y" /* yacc.c:1646  */
+#line 522 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.list) = symbol_list_append ((yyvsp[-1].list), (yyvsp[0].list)); }
-#line 2484 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2550 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 65:
-#line 525 "src/parse-gram.y" /* yacc.c:1646  */
+#line 526 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.list) = symbol_list_sym_new ((yyvsp[0].symbol), (yylsp[0])); }
-#line 2490 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2556 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 66:
-#line 526 "src/parse-gram.y" /* yacc.c:1646  */
+#line 527 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.list) = symbol_list_type_new ((yyvsp[0].uniqstr), (yylsp[0])); }
-#line 2496 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2562 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 68:
-#line 531 "src/parse-gram.y" /* yacc.c:1646  */
+#line 532 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.uniqstr) = uniqstr_new ("*"); }
-#line 2502 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2568 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 69:
-#line 532 "src/parse-gram.y" /* yacc.c:1646  */
+#line 533 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.uniqstr) = uniqstr_new (""); }
-#line 2508 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2574 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 70:
-#line 538 "src/parse-gram.y" /* yacc.c:1646  */
+#line 539 "src/parse-gram.y" /* yacc.c:1646  */
     {
       current_type = (yyvsp[0].uniqstr);
       tag_seen = true;
     }
-#line 2517 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2583 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 71:
-#line 543 "src/parse-gram.y" /* yacc.c:1646  */
+#line 544 "src/parse-gram.y" /* yacc.c:1646  */
     {
       symbol_class_set ((yyvsp[0].symbol), current_class, (yylsp[0]), true);
       symbol_type_set ((yyvsp[0].symbol), current_type, (yylsp[0]));
     }
-#line 2526 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2592 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 72:
-#line 548 "src/parse-gram.y" /* yacc.c:1646  */
+#line 549 "src/parse-gram.y" /* yacc.c:1646  */
     {
       symbol_class_set ((yyvsp[-1].symbol), current_class, (yylsp[-1]), true);
       symbol_type_set ((yyvsp[-1].symbol), current_type, (yylsp[-1]));
       symbol_user_token_number_set ((yyvsp[-1].symbol), (yyvsp[0].integer), (yylsp[0]));
     }
-#line 2536 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2602 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 73:
-#line 554 "src/parse-gram.y" /* yacc.c:1646  */
+#line 555 "src/parse-gram.y" /* yacc.c:1646  */
     {
       symbol_class_set ((yyvsp[-1].symbol), current_class, (yylsp[-1]), true);
       symbol_type_set ((yyvsp[-1].symbol), current_type, (yylsp[-1]));
       symbol_make_alias ((yyvsp[-1].symbol), (yyvsp[0].symbol), (yyloc));
     }
-#line 2546 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2612 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 74:
-#line 560 "src/parse-gram.y" /* yacc.c:1646  */
+#line 561 "src/parse-gram.y" /* yacc.c:1646  */
     {
       symbol_class_set ((yyvsp[-2].symbol), current_class, (yylsp[-2]), true);
       symbol_type_set ((yyvsp[-2].symbol), current_type, (yylsp[-2]));
       symbol_user_token_number_set ((yyvsp[-2].symbol), (yyvsp[-1].integer), (yylsp[-1]));
       symbol_make_alias ((yyvsp[-2].symbol), (yyvsp[0].symbol), (yyloc));
     }
-#line 2557 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2623 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 81:
-#line 590 "src/parse-gram.y" /* yacc.c:1646  */
+#line 591 "src/parse-gram.y" /* yacc.c:1646  */
     {
       yyerrok;
     }
-#line 2565 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2631 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 82:
-#line 596 "src/parse-gram.y" /* yacc.c:1646  */
+#line 597 "src/parse-gram.y" /* yacc.c:1646  */
     { current_lhs ((yyvsp[-1].symbol), (yylsp[-1]), (yyvsp[0].named_ref)); }
-#line 2571 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2637 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 83:
-#line 597 "src/parse-gram.y" /* yacc.c:1646  */
+#line 598 "src/parse-gram.y" /* yacc.c:1646  */
     {
     /* Free the current lhs. */
     current_lhs (0, (yylsp[-3]), 0);
   }
-#line 2580 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2646 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 84:
-#line 604 "src/parse-gram.y" /* yacc.c:1646  */
+#line 605 "src/parse-gram.y" /* yacc.c:1646  */
     { grammar_current_rule_end ((yylsp[0])); }
-#line 2586 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2652 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 85:
-#line 605 "src/parse-gram.y" /* yacc.c:1646  */
+#line 606 "src/parse-gram.y" /* yacc.c:1646  */
     { grammar_current_rule_end ((yylsp[0])); }
-#line 2592 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2658 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 87:
-#line 612 "src/parse-gram.y" /* yacc.c:1646  */
+#line 613 "src/parse-gram.y" /* yacc.c:1646  */
     { grammar_current_rule_begin (current_lhs_symbol, current_lhs_location,
                                   current_lhs_named_ref); }
-#line 2599 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2665 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 88:
-#line 615 "src/parse-gram.y" /* yacc.c:1646  */
+#line 616 "src/parse-gram.y" /* yacc.c:1646  */
     { grammar_current_rule_symbol_append ((yyvsp[-1].symbol), (yylsp[-1]), (yyvsp[0].named_ref)); }
-#line 2605 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2671 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 89:
-#line 617 "src/parse-gram.y" /* yacc.c:1646  */
-    { grammar_current_rule_action_append ((yyvsp[-1].code), (yylsp[-1]), (yyvsp[0].named_ref), false); }
-#line 2611 "src/parse-gram.c" /* yacc.c:1646  */
+#line 618 "src/parse-gram.y" /* yacc.c:1646  */
+    { grammar_current_rule_action_append ((yyvsp[-1].code), (yylsp[-1]), (yyvsp[0].named_ref), false, true); }
+#line 2677 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 90:
-#line 619 "src/parse-gram.y" /* yacc.c:1646  */
-    { grammar_current_rule_action_append ((yyvsp[0].code), (yylsp[0]), NULL, true); }
-#line 2617 "src/parse-gram.c" /* yacc.c:1646  */
+#line 620 "src/parse-gram.y" /* yacc.c:1646  */
+    { grammar_current_rule_action_append ((yyvsp[-1].code), (yylsp[-1]), (yyvsp[0].named_ref), false, false); }
+#line 2683 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 91:
-#line 621 "src/parse-gram.y" /* yacc.c:1646  */
-    { grammar_current_rule_empty_set ((yylsp[0])); }
-#line 2623 "src/parse-gram.c" /* yacc.c:1646  */
+#line 622 "src/parse-gram.y" /* yacc.c:1646  */
+    { grammar_current_rule_action_append ((yyvsp[0].code), (yylsp[0]), NULL, true, false); }
+#line 2689 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 92:
-#line 623 "src/parse-gram.y" /* yacc.c:1646  */
-    { grammar_current_rule_prec_set ((yyvsp[0].symbol), (yylsp[0])); }
-#line 2629 "src/parse-gram.c" /* yacc.c:1646  */
+#line 624 "src/parse-gram.y" /* yacc.c:1646  */
+    { grammar_current_rule_empty_set ((yylsp[0])); }
+#line 2695 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 93:
-#line 625 "src/parse-gram.y" /* yacc.c:1646  */
-    { grammar_current_rule_dprec_set ((yyvsp[0].integer), (yylsp[0])); }
-#line 2635 "src/parse-gram.c" /* yacc.c:1646  */
+#line 626 "src/parse-gram.y" /* yacc.c:1646  */
+    { grammar_current_rule_prec_set ((yyvsp[0].symbol), (yylsp[0])); }
+#line 2701 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 94:
-#line 627 "src/parse-gram.y" /* yacc.c:1646  */
-    { grammar_current_rule_merge_set ((yyvsp[0].uniqstr), (yylsp[0])); }
-#line 2641 "src/parse-gram.c" /* yacc.c:1646  */
+#line 628 "src/parse-gram.y" /* yacc.c:1646  */
+    { grammar_current_rule_dprec_set ((yyvsp[0].integer), (yylsp[0])); }
+#line 2707 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 95:
-#line 631 "src/parse-gram.y" /* yacc.c:1646  */
-    { (yyval.named_ref) = 0; }
-#line 2647 "src/parse-gram.c" /* yacc.c:1646  */
+#line 630 "src/parse-gram.y" /* yacc.c:1646  */
+    { grammar_current_rule_merge_set ((yyvsp[0].uniqstr), (yylsp[0])); }
+#line 2713 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
   case 96:
-#line 632 "src/parse-gram.y" /* yacc.c:1646  */
+#line 634 "src/parse-gram.y" /* yacc.c:1646  */
+    { (yyval.named_ref) = 0; }
+#line 2719 "src/parse-gram.c" /* yacc.c:1646  */
+    break;
+
+  case 97:
+#line 635 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.named_ref) = named_ref_new ((yyvsp[0].uniqstr), (yylsp[0])); }
-#line 2653 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2725 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 98:
-#line 643 "src/parse-gram.y" /* yacc.c:1646  */
+  case 99:
+#line 646 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.uniqstr) = uniqstr_new ((yyvsp[0].code)); }
-#line 2659 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2731 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 99:
-#line 668 "src/parse-gram.y" /* yacc.c:1646  */
+  case 100:
+#line 671 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.value).kind = muscle_keyword; (yyval.value).chars = ""; }
-#line 2665 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2737 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 100:
-#line 669 "src/parse-gram.y" /* yacc.c:1646  */
+  case 101:
+#line 672 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.value).kind = muscle_keyword; (yyval.value).chars = (yyvsp[0].uniqstr); }
-#line 2671 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2743 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 101:
-#line 670 "src/parse-gram.y" /* yacc.c:1646  */
+  case 102:
+#line 673 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.value).kind = muscle_string;  (yyval.value).chars = (yyvsp[0].code); }
-#line 2677 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2749 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 102:
-#line 671 "src/parse-gram.y" /* yacc.c:1646  */
+  case 103:
+#line 674 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.value).kind = muscle_code;    (yyval.value).chars = strip_braces ((yyvsp[0].code)); }
-#line 2683 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2755 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 103:
-#line 684 "src/parse-gram.y" /* yacc.c:1646  */
+  case 104:
+#line 687 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.symbol) = symbol_from_uniqstr ((yyvsp[0].uniqstr), (yylsp[0])); }
-#line 2689 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2761 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 104:
-#line 686 "src/parse-gram.y" /* yacc.c:1646  */
+  case 105:
+#line 689 "src/parse-gram.y" /* yacc.c:1646  */
     {
       (yyval.symbol) = symbol_get (char_name ((yyvsp[0].character)), (yylsp[0]));
       symbol_class_set ((yyval.symbol), token_sym, (yylsp[0]), false);
       symbol_user_token_number_set ((yyval.symbol), (yyvsp[0].character), (yylsp[0]));
     }
-#line 2699 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2771 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 105:
-#line 694 "src/parse-gram.y" /* yacc.c:1646  */
+  case 106:
+#line 697 "src/parse-gram.y" /* yacc.c:1646  */
     { (yyval.symbol) = symbol_from_uniqstr ((yyvsp[0].uniqstr), (yylsp[0])); }
-#line 2705 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2777 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 108:
-#line 706 "src/parse-gram.y" /* yacc.c:1646  */
+  case 109:
+#line 709 "src/parse-gram.y" /* yacc.c:1646  */
     {
       (yyval.symbol) = symbol_get (quotearg_style (c_quoting_style, (yyvsp[0].code)), (yylsp[0]));
       symbol_class_set ((yyval.symbol), token_sym, (yylsp[0]), false);
     }
-#line 2714 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2786 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
-  case 110:
-#line 715 "src/parse-gram.y" /* yacc.c:1646  */
+  case 111:
+#line 718 "src/parse-gram.y" /* yacc.c:1646  */
     {
       muscle_code_grow ("epilogue", translate_code ((yyvsp[0].code), (yylsp[0]), true), (yylsp[0]));
       code_scanner_last_string_free ();
     }
-#line 2723 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2795 "src/parse-gram.c" /* yacc.c:1646  */
     break;
 
 
-#line 2727 "src/parse-gram.c" /* yacc.c:1646  */
+#line 2799 "src/parse-gram.c" /* yacc.c:1646  */
         default: break;
       }
     if (yychar_backup != yychar)
@@ -2970,7 +3042,7 @@
 #endif
   return yyresult;
 }
-#line 721 "src/parse-gram.y" /* yacc.c:1906  */
+#line 724 "src/parse-gram.y" /* yacc.c:1906  */
 
 
 /* Return the location of the left-hand side of a rule whose
diff -ruN bison-3.0.4/src/parse-gram.h bison-3.0.4b/src/parse-gram.h
--- bison-3.0.4/src/parse-gram.h	2015-01-23 05:28:31.000000000 -0500
+++ bison-3.0.4b/src/parse-gram.h	2015-12-23 21:10:11.175501000 -0500
@@ -1,4 +1,4 @@
-/* A Bison parser, made by GNU Bison 3.0.2.13-975bb-dirty.  */
+/* A Bison parser, made by GNU Bison 3.0.4.  */
 
 /* Bison interface for Yacc-like parsers in C
 
@@ -52,7 +52,7 @@
 
   #include "symlist.h"
   #include "symtab.h"
-#line 221 "src/parse-gram.y" /* yacc.c:1909  */
+#line 222 "src/parse-gram.y" /* yacc.c:1909  */
 
   typedef enum
   {
@@ -61,7 +61,7 @@
     param_parse  = 1 << 1,
     param_both   = param_lex | param_parse
   } param_type;
-#line 647 "src/parse-gram.y" /* yacc.c:1909  */
+#line 650 "src/parse-gram.y" /* yacc.c:1909  */
 #include "muscle-tab.h"
 
 #line 68 "src/parse-gram.h" /* yacc.c:1909  */
@@ -109,53 +109,112 @@
     PERCENT_VERBOSE = 292,
     PERCENT_YACC = 293,
     BRACED_CODE = 294,
-    BRACED_PREDICATE = 295,
-    BRACKETED_ID = 296,
-    CHAR = 297,
-    EPILOGUE = 298,
-    EQUAL = 299,
-    ID = 300,
-    ID_COLON = 301,
-    PERCENT_PERCENT = 302,
-    PIPE = 303,
-    PROLOGUE = 304,
-    SEMICOLON = 305,
-    TAG = 306,
-    TAG_ANY = 307,
-    TAG_NONE = 308,
-    INT = 309,
-    PERCENT_PARAM = 310,
-    PERCENT_UNION = 311,
-    PERCENT_EMPTY = 312
+    BRACED_PLAIN_CODE = 295,
+    BRACED_PREDICATE = 296,
+    BRACKETED_ID = 297,
+    CHAR = 298,
+    EPILOGUE = 299,
+    EQUAL = 300,
+    ID = 301,
+    ID_COLON = 302,
+    PERCENT_PERCENT = 303,
+    PIPE = 304,
+    PROLOGUE = 305,
+    SEMICOLON = 306,
+    TAG = 307,
+    TAG_ANY = 308,
+    TAG_NONE = 309,
+    INT = 310,
+    PERCENT_PARAM = 311,
+    PERCENT_UNION = 312,
+    PERCENT_EMPTY = 313
   };
 #endif
+/* Tokens.  */
+#define GRAM_EOF 0
+#define STRING 258
+#define PERCENT_TOKEN 259
+#define PERCENT_NTERM 260
+#define PERCENT_TYPE 261
+#define PERCENT_DESTRUCTOR 262
+#define PERCENT_PRINTER 263
+#define PERCENT_LEFT 264
+#define PERCENT_RIGHT 265
+#define PERCENT_NONASSOC 266
+#define PERCENT_PRECEDENCE 267
+#define PERCENT_PREC 268
+#define PERCENT_DPREC 269
+#define PERCENT_MERGE 270
+#define PERCENT_CODE 271
+#define PERCENT_DEFAULT_PREC 272
+#define PERCENT_DEFINE 273
+#define PERCENT_DEFINES 274
+#define PERCENT_ERROR_VERBOSE 275
+#define PERCENT_EXPECT 276
+#define PERCENT_EXPECT_RR 277
+#define PERCENT_FLAG 278
+#define PERCENT_FILE_PREFIX 279
+#define PERCENT_GLR_PARSER 280
+#define PERCENT_INITIAL_ACTION 281
+#define PERCENT_LANGUAGE 282
+#define PERCENT_NAME_PREFIX 283
+#define PERCENT_NO_DEFAULT_PREC 284
+#define PERCENT_NO_LINES 285
+#define PERCENT_NONDETERMINISTIC_PARSER 286
+#define PERCENT_OUTPUT 287
+#define PERCENT_REQUIRE 288
+#define PERCENT_SKELETON 289
+#define PERCENT_START 290
+#define PERCENT_TOKEN_TABLE 291
+#define PERCENT_VERBOSE 292
+#define PERCENT_YACC 293
+#define BRACED_CODE 294
+#define BRACED_PLAIN_CODE 295
+#define BRACED_PREDICATE 296
+#define BRACKETED_ID 297
+#define CHAR 298
+#define EPILOGUE 299
+#define EQUAL 300
+#define ID 301
+#define ID_COLON 302
+#define PERCENT_PERCENT 303
+#define PIPE 304
+#define PROLOGUE 305
+#define SEMICOLON 306
+#define TAG 307
+#define TAG_ANY 308
+#define TAG_NONE 309
+#define INT 310
+#define PERCENT_PARAM 311
+#define PERCENT_UNION 312
+#define PERCENT_EMPTY 313
 
 /* Value type.  */
 #if ! defined GRAM_STYPE && ! defined GRAM_STYPE_IS_DECLARED
 
 union GRAM_STYPE
 {
-#line 182 "src/parse-gram.y" /* yacc.c:1909  */
+#line 183 "src/parse-gram.y" /* yacc.c:1909  */
 unsigned char character;
-#line 186 "src/parse-gram.y" /* yacc.c:1909  */
+#line 187 "src/parse-gram.y" /* yacc.c:1909  */
 char *code;
-#line 191 "src/parse-gram.y" /* yacc.c:1909  */
+#line 192 "src/parse-gram.y" /* yacc.c:1909  */
 uniqstr uniqstr;
-#line 199 "src/parse-gram.y" /* yacc.c:1909  */
+#line 200 "src/parse-gram.y" /* yacc.c:1909  */
 int integer;
-#line 203 "src/parse-gram.y" /* yacc.c:1909  */
+#line 204 "src/parse-gram.y" /* yacc.c:1909  */
 symbol *symbol;
-#line 208 "src/parse-gram.y" /* yacc.c:1909  */
+#line 209 "src/parse-gram.y" /* yacc.c:1909  */
 assoc assoc;
-#line 211 "src/parse-gram.y" /* yacc.c:1909  */
+#line 212 "src/parse-gram.y" /* yacc.c:1909  */
 symbol_list *list;
-#line 214 "src/parse-gram.y" /* yacc.c:1909  */
+#line 215 "src/parse-gram.y" /* yacc.c:1909  */
 named_ref *named_ref;
-#line 241 "src/parse-gram.y" /* yacc.c:1909  */
+#line 242 "src/parse-gram.y" /* yacc.c:1909  */
 param_type param;
-#line 409 "src/parse-gram.y" /* yacc.c:1909  */
+#line 410 "src/parse-gram.y" /* yacc.c:1909  */
 code_props_type code_type;
-#line 649 "src/parse-gram.y" /* yacc.c:1909  */
+#line 652 "src/parse-gram.y" /* yacc.c:1909  */
 
   struct
   {
@@ -163,7 +222,7 @@
     muscle_kind kind;
   } value;
 
-#line 167 "src/parse-gram.h" /* yacc.c:1909  */
+#line 226 "src/parse-gram.h" /* yacc.c:1909  */
 };
 
 typedef union GRAM_STYPE GRAM_STYPE;
diff -ruN bison-3.0.4/src/parse-gram.y bison-3.0.4b/src/parse-gram.y
--- bison-3.0.4/src/parse-gram.y	2015-01-18 09:01:16.000000000 -0500
+++ bison-3.0.4b/src/parse-gram.y	2015-12-23 21:10:06.151292100 -0500
@@ -164,6 +164,7 @@
 ;
 
 %token BRACED_CODE     "{...}"
+%token BRACED_PLAIN_CODE "%!{...}"
 %token BRACED_PREDICATE "%?{...}"
 %token BRACKETED_ID    "[identifier]"
 %token CHAR            "char"
@@ -184,7 +185,7 @@
 %printer { fputs (char_name ($$), yyo); } CHAR
 
 %union {char *code;};
-%type <code> "{...}" "%?{...}" "%{...%}" EPILOGUE STRING
+%type <code> "{...}" "%!{...}" "%?{...}" "%{...%}" EPILOGUE STRING
 %printer { fputs (quotearg_style (c_quoting_style, $$), yyo); } STRING
 %printer { fprintf (yyo, "{\n%s\n}", $$); } <code>
 
@@ -614,9 +615,11 @@
 | rhs symbol named_ref.opt
     { grammar_current_rule_symbol_append ($2, @2, $3); }
 | rhs "{...}" named_ref.opt
-    { grammar_current_rule_action_append ($2, @2, $3, false); }
+    { grammar_current_rule_action_append ($2, @2, $3, false, true); }
+| rhs "%!{...}" named_ref.opt
+    { grammar_current_rule_action_append ($2, @2, $3, false, false); }
 | rhs "%?{...}"
-    { grammar_current_rule_action_append ($2, @2, NULL, true); }
+    { grammar_current_rule_action_append ($2, @2, NULL, true, false); }
 | rhs "%empty"
     { grammar_current_rule_empty_set (@2); }
 | rhs "%prec" symbol
diff -ruN bison-3.0.4/src/reader.c bison-3.0.4b/src/reader.c
--- bison-3.0.4/src/reader.c	2015-01-18 09:01:16.000000000 -0500
+++ bison-3.0.4b/src/reader.c	2015-12-23 21:13:28.264048800 -0500
@@ -377,7 +377,7 @@
 `-------------------------------------------------------------------*/
 
 void
-grammar_midrule_action (void)
+grammar_midrule_action ()
 {
   /* Since the action was written out with this rule's number, we must
      give the new rule this number by inserting the new rule before
@@ -402,7 +402,8 @@
                                current_rule->action_props.code,
                                current_rule->action_props.location,
                                midrule, 0,
-                               current_rule->action_props.is_predicate);
+                               current_rule->action_props.is_predicate,
+                               current_rule->action_props.kind != CODE_PROPS_NONE);
   code_props_none_init (&current_rule->action_props);
 
   if (previous_rule_end)
@@ -525,14 +526,14 @@
 
 void
 grammar_current_rule_action_append (const char *action, location loc,
-                                    named_ref *name, bool is_predicate)
+                                    named_ref *name, bool is_predicate, bool translate)
 {
   if (current_rule->action_props.code)
     grammar_midrule_action ();
   /* After all symbol declarations have been parsed, packgram invokes
      code_props_translate_code.  */
   code_props_rule_action_init (&current_rule->action_props, action, loc,
-                               current_rule, name, is_predicate);
+                               current_rule, name, is_predicate, translate);
 }
 
 
diff -ruN bison-3.0.4/src/reader.h bison-3.0.4b/src/reader.h
--- bison-3.0.4/src/reader.h	2015-01-16 09:47:42.000000000 -0500
+++ bison-3.0.4b/src/reader.h	2015-12-23 21:11:26.065633100 -0500
@@ -55,7 +55,7 @@
 void grammar_current_rule_symbol_append (symbol *sym, location loc,
                                          named_ref *nref);
 void grammar_current_rule_action_append (const char *action, location loc,
-                                         named_ref *nref, bool);
+                                         named_ref *nref, bool, bool);
 void reader (void);
 void free_merger_functions (void);
 
diff -ruN bison-3.0.4/src/scan-code.c bison-3.0.4b/src/scan-code.c
--- bison-3.0.4/src/scan-code.c	2015-01-22 11:04:33.000000000 -0500
+++ bison-3.0.4b/src/scan-code.c	2015-12-30 21:03:41.239910600 -0500
@@ -36,7 +36,7 @@
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 37
+#define YY_FLEX_SUBMINOR_VERSION 39
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -235,6 +235,7 @@
 #define EOB_ACT_LAST_MATCH 2
 
     #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
     
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
@@ -443,6 +444,8 @@
 extern char *code_text;
 #define yytext_ptr code_text
 
+/* %% [1.5] DFA */
+
 /* %if-c-only Standard (non-C++) definition */
 
 static yy_state_type yy_get_previous_state (void );
@@ -474,17 +477,19 @@
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[91] =
+static yyconst flex_int16_t yy_accept[93] =
     {   0,
         0,    0,    0,    0,    3,    3,    4,    4,    4,    4,
         0,    0,    0,    0,   19,   17,   16,   17,    2,   17,
-        6,   17,    5,    8,   11,    7,   17,   11,   11,   11,
+        6,   17,    5,    8,   16,    7,   17,   16,   16,   16,
         1,    0,    0,    3,    4,    4,    4,    4,   12,    0,
-       12,   12,    0,    0,    9,   10,    0,   13,    0,   13,
-       13,    0,   14,    0,   15,    0,    0,    0,    0,    0,
-        0,    0,   12,    0,    0,    0,    0,    0,   13,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,   12,    0,
-       12,   12,    0,   14,   12,   12,    0,    0,    0,    0
+       12,   12,    0,    0,    0,    9,   10,    0,   13,    0,
+       13,   13,    0,   14,    0,   15,    0,    0,    0,    0,
+        0,    0,    0,   12,    0,    0,    0,   11,    0,    0,
+       13,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       12,    0,   12,   12,    0,   14,   12,   12,    0,    0,
+        0,    0
+
     } ;
 
 static yyconst flex_int32_t yy_ec[256] =
@@ -502,7 +507,7 @@
 
         9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
         9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-        9,    9,    1,    1,    1,    1,    1,    1,    1,    1,
+        9,    9,    1,   18,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -519,92 +524,96 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst flex_int32_t yy_meta[19] =
+static yyconst flex_int32_t yy_meta[20] =
     {   0,
         1,    1,    2,    1,    1,    1,    1,    3,    3,    1,
-        3,    1,    2,    1,    1,    1,    1,    2
+        3,    1,    2,    1,    1,    1,    1,    1,    2
     } ;
 
-static yyconst flex_int16_t yy_base[97] =
+static yyconst flex_int16_t yy_base[99] =
     {   0,
-        0,   13,  121,  120,    0,    3,    4,    5,    6,    7,
-       27,    0,   20,   21,  125,  178,  178,   26,  178,    8,
-      178,   41,  178,  178,   53,  178,   62,   74,   33,  119,
-      178,   37,   44,  105,  178,   46,  101,   48,  178,   99,
-        0,   96,   98,   91,  178,  178,   50,  178,   87,    0,
-       86,   87,  178,   76,  178,   52,   50,   68,   71,   73,
-       78,   74,    0,   16,   78,   84,   85,    0,    0,   94,
-       86,   96,   55,  107,    0,    0,   58,  118,  100,  124,
-      130,  136,  142,  106,   46,    0,  148,   43,    0,  178,
-      165,  168,    4,  171,    1,  174
+        0,   13,  116,  115,    0,    3,    4,    5,    6,    7,
+       27,    0,   20,   21,  121,  193,  193,   26,  193,    8,
+      193,   41,  193,  193,   53,  193,   65,   77,   88,  114,
+      193,   36,   43,   99,  193,   45,   98,   47,  193,  102,
+        0,  101,  103,  100,   91,  193,  193,   49,  193,   93,
+        0,   92,   89,  193,   79,  193,   51,   50,   53,   67,
+       71,   74,   64,    0,   16,   70,   99,  193,   87,    0,
+        0,  109,   71,   83,   83,  122,    0,    0,   58,  133,
+       86,  139,  145,  151,  157,   89,   46,    0,  163,   27,
+        0,  193,  180,  183,    4,  186,    1,  189
 
     } ;
 
-static yyconst flex_int16_t yy_def[97] =
+static yyconst flex_int16_t yy_def[99] =
     {   0,
-       91,   91,    2,    2,    2,    2,    2,    2,    2,    2,
-        2,   11,   11,   11,   90,   90,   90,   90,   90,   90,
-       90,   92,   90,   90,   90,   90,   90,   90,   90,   90,
-       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
-       93,   90,   94,   90,   90,   90,   90,   90,   90,   95,
-       90,   90,   90,   96,   90,   90,   90,   90,   90,   90,
-       90,   92,   93,   94,   94,   90,   90,   27,   95,   90,
-       96,   96,   25,   94,   66,   70,   90,   96,   94,   94,
-       94,   94,   94,   96,   81,   81,   81,   87,   87,    0,
-       90,   90,   90,   90,   90,   90
+       93,   93,    2,    2,    2,    2,    2,    2,    2,    2,
+        2,   11,   11,   11,   92,   92,   92,   92,   92,   92,
+       92,   94,   92,   92,   92,   92,   92,   92,   92,   92,
+       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
+       95,   92,   96,   92,   92,   92,   92,   92,   92,   92,
+       97,   92,   92,   92,   98,   92,   92,   92,   92,   92,
+       92,   92,   94,   95,   96,   96,   92,   92,   92,   27,
+       97,   92,   98,   98,   25,   96,   67,   72,   92,   98,
+       96,   96,   96,   96,   96,   98,   83,   83,   83,   89,
+       89,    0,   92,   92,   92,   92,   92,   92
 
     } ;
 
-static yyconst flex_int16_t yy_nxt[197] =
+static yyconst flex_int16_t yy_nxt[213] =
     {   0,
-       90,   90,   19,   69,   17,   19,   63,   21,   21,   33,
+       92,   92,   19,   71,   17,   19,   64,   21,   21,   33,
        34,   23,   23,   17,   17,   20,   17,   17,   20,   22,
-       22,   22,   22,   65,   29,   29,   17,   17,   73,   17,
-       24,   25,   26,   30,   30,   31,   27,   53,   56,   57,
-       28,   32,   36,   37,   54,   33,   34,   59,   37,   61,
-       62,   67,   68,   56,   57,   74,   38,   39,   74,   31,
-       40,   41,   53,   42,   43,   32,   90,   44,   45,   33,
-       34,   46,   59,   37,   59,   37,   90,   47,   48,   61,
-       62,   49,   50,   72,   51,   65,   67,   68,   52,   38,
-       74,   75,   75,   72,   75,   70,   51,   51,   77,   66,
-
-       39,   76,   76,   72,   76,   65,   42,   65,   78,   42,
-       48,   79,   73,   72,   80,   81,   60,   82,   77,   73,
-       58,   83,   84,   55,   90,   72,   18,   18,   90,   90,
-       77,   65,   90,   90,   82,   90,   74,   85,   86,   90,
-       86,   90,   73,   65,   90,   90,   82,   90,   73,   65,
-       87,   90,   90,   90,   73,   88,   89,   90,   89,   90,
-       90,   90,   90,   90,   79,   16,   16,   16,   35,   35,
-       35,   64,   90,   64,   71,   90,   71,   15,   90,   90,
-       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
-       90,   90,   90,   90,   90,   90
+       22,   22,   22,   66,   29,   29,   17,   17,   75,   17,
+       24,   25,   26,   30,   30,   31,   27,   57,   58,   76,
+       28,   32,   36,   37,   33,   34,   60,   37,   62,   63,
+       69,   70,   57,   58,   33,   34,   38,   39,   76,   31,
+       40,   41,   54,   42,   43,   32,   92,   44,   60,   37,
+       45,   46,   60,   37,   47,   62,   63,   66,   74,   38,
+       48,   49,   76,   79,   50,   51,   74,   52,   69,   70,
+       74,   53,   54,   66,   92,   80,   74,   72,   75,   55,
+
+       92,   79,   52,   52,   68,   45,   77,   77,   67,   77,
+       66,   42,   42,   61,   59,   39,   78,   78,   56,   78,
+       92,   18,   18,   92,   92,   49,   81,   92,   92,   82,
+       83,   92,   84,   92,   75,   92,   85,   86,   92,   92,
+       74,   92,   92,   92,   92,   79,   66,   92,   92,   84,
+       92,   76,   87,   88,   92,   88,   92,   75,   66,   92,
+       92,   84,   92,   75,   66,   89,   92,   92,   92,   75,
+       90,   91,   92,   91,   92,   92,   92,   92,   92,   81,
+       16,   16,   16,   35,   35,   35,   65,   92,   65,   73,
+       92,   73,   15,   92,   92,   92,   92,   92,   92,   92,
 
+       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
+       92,   92
     } ;
 
-static yyconst flex_int16_t yy_chk[197] =
+static yyconst flex_int16_t yy_chk[213] =
     {   0,
-        0,    0,    5,   95,    1,    6,   93,    7,    8,   20,
+        0,    0,    5,   97,    1,    6,   95,    7,    8,   20,
        20,    9,   10,    1,    1,    5,    1,    2,    6,    7,
-        8,    9,   10,   64,   13,   14,    2,    2,   64,    2,
-       11,   11,   11,   13,   14,   18,   11,   29,   32,   32,
-       11,   18,   22,   22,   29,   33,   33,   36,   36,   38,
-       38,   47,   47,   56,   56,   88,   22,   25,   85,   57,
-       25,   25,   77,   25,   25,   57,   73,   25,   27,   58,
-       58,   27,   59,   59,   60,   60,   62,   27,   28,   61,
-       61,   28,   28,   54,   28,   65,   67,   67,   28,   62,
-       65,   66,   66,   71,   66,   52,   51,   49,   71,   44,
-
-       66,   70,   70,   72,   70,   43,   42,   79,   72,   40,
-       70,   74,   79,   84,   74,   74,   37,   74,   84,   74,
-       34,   74,   78,   30,   15,   78,    4,    3,    0,    0,
-       78,   80,    0,    0,   80,    0,   80,   81,   81,    0,
-       81,    0,   81,   82,    0,    0,   82,    0,   82,   83,
-       83,    0,    0,    0,   83,   87,   87,    0,   87,    0,
-        0,    0,    0,    0,   87,   91,   91,   91,   92,   92,
-       92,   94,    0,   94,   96,    0,   96,   90,   90,   90,
-       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
-       90,   90,   90,   90,   90,   90
+        8,    9,   10,   65,   13,   14,    2,    2,   65,    2,
+       11,   11,   11,   13,   14,   18,   11,   32,   32,   90,
+       11,   18,   22,   22,   33,   33,   36,   36,   38,   38,
+       48,   48,   57,   57,   59,   59,   22,   25,   87,   58,
+       25,   25,   79,   25,   25,   58,   63,   25,   60,   60,
+       25,   27,   61,   61,   27,   62,   62,   66,   73,   63,
+       27,   28,   66,   73,   28,   28,   55,   28,   69,   69,
+       74,   28,   29,   81,   75,   74,   86,   53,   81,   29,
+
+       75,   86,   52,   50,   45,   29,   67,   67,   44,   67,
+       43,   42,   40,   37,   34,   67,   72,   72,   30,   72,
+       15,    4,    3,    0,    0,   72,   76,    0,    0,   76,
+       76,    0,   76,    0,   76,    0,   76,   80,    0,    0,
+       80,    0,    0,    0,    0,   80,   82,    0,    0,   82,
+        0,   82,   83,   83,    0,   83,    0,   83,   84,    0,
+        0,   84,    0,   84,   85,   85,    0,    0,    0,   85,
+       89,   89,    0,   89,    0,    0,    0,    0,    0,   89,
+       93,   93,   93,   94,   94,   94,   96,    0,   96,   98,
+        0,   98,   92,   92,   92,   92,   92,   92,   92,   92,
 
+       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
+       92,   92
     } ;
 
 static yy_state_type yy_last_accepting_state;
@@ -627,7 +636,7 @@
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
 char *code_text;
-#line 1 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 1 "src/scan-code.l"
 /* Bison Action Scanner                             -*- C -*-
 
    Copyright (C) 2006-2015 Free Software Foundation, Inc.
@@ -647,7 +656,7 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #define YY_NO_INPUT 1
-#line 24 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 24 "src/scan-code.l"
 /* Work around a bug in flex 2.5.31.  See Debian bug 333231
    <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=333231>.  */
 #undef code_wrap
@@ -669,7 +678,7 @@
 
 /* The current calling start condition: SC_RULE_ACTION or
    SC_SYMBOL_ACTION. */
-# define YY_DECL static char *code_lex (code_props *self, int sc_context)
+# define YY_DECL char *code_lex (code_props *self, int sc_context)
 YY_DECL;
 
 #define YY_USER_ACTION  location_compute (loc, &loc->end, code_text, code_leng);
@@ -709,7 +718,7 @@
 /* C style identifier. Must start with letter. Will be used for
    named symbol references. Shall be kept synchronized with
    scan-gram.l "letter" and "id". */
-#line 713 "src/scan-code.c"
+#line 722 "src/scan-code.c"
 
 #define INITIAL 0
 #define SC_COMMENT 1
@@ -954,26 +963,6 @@
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
     
-/* %% [7.0] user's declarations go here */
-#line 96 "/Users/akim/src/gnu/bison/src/scan-code.l"
-
-
-
-  /* This scanner is special: it is invoked only once, henceforth
-     is expected to return only once.  This initialization is
-     therefore done once per action to translate. */
-  aver (sc_context == SC_SYMBOL_ACTION
-        || sc_context == SC_RULE_ACTION
-        || sc_context == INITIAL);
-  BEGIN sc_context;
-
-
-  /*------------------------------------------------------------.
-  | Scanning a C comment.  The initial '/ *' is already eaten.  |
-  `------------------------------------------------------------*/
-
-#line 976 "src/scan-code.c"
-
 	if ( !(yy_init) )
 		{
 		(yy_init) = 1;
@@ -1008,6 +997,27 @@
 		code__load_buffer_state( );
 		}
 
+	{
+/* %% [7.0] user's declarations go here */
+#line 96 "src/scan-code.l"
+
+
+
+  /* This scanner is special: it is invoked only once, henceforth
+     is expected to return only once.  This initialization is
+     therefore done once per action to translate. */
+  aver (sc_context == SC_SYMBOL_ACTION
+        || sc_context == SC_RULE_ACTION
+        || sc_context == INITIAL);
+  BEGIN sc_context;
+
+
+  /*------------------------------------------------------------.
+  | Scanning a C comment.  The initial '/ *' is already eaten.  |
+  `------------------------------------------------------------*/
+
+#line 1020 "src/scan-code.c"
+
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
 /* %% [8.0] yymore()-related code goes here */
@@ -1026,7 +1036,7 @@
 yy_match:
 		do
 			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
 			if ( yy_accept[yy_current_state] )
 				{
 				(yy_last_accepting_state) = yy_current_state;
@@ -1035,13 +1045,13 @@
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 91 )
+				if ( yy_current_state >= 93 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_current_state != 90 );
+		while ( yy_current_state != 92 );
 		yy_cp = (yy_last_accepting_cpos);
 		yy_current_state = (yy_last_accepting_state);
 
@@ -1085,7 +1095,7 @@
 case 1:
 /* rule 1 can match eol */
 YY_RULE_SETUP
-#line 114 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 114 "src/scan-code.l"
 STRING_GROW; BEGIN sc_context;
 	YY_BREAK
 
@@ -1097,13 +1107,13 @@
 case 2:
 /* rule 2 can match eol */
 YY_RULE_SETUP
-#line 124 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 124 "src/scan-code.l"
 STRING_GROW; BEGIN sc_context;
 	YY_BREAK
 case 3:
 /* rule 3 can match eol */
 YY_RULE_SETUP
-#line 125 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 125 "src/scan-code.l"
 STRING_GROW;
 	YY_BREAK
 
@@ -1115,7 +1125,7 @@
 case 4:
 /* rule 4 can match eol */
 YY_RULE_SETUP
-#line 135 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 135 "src/scan-code.l"
 STRING_GROW;
 	YY_BREAK
 
@@ -1123,7 +1133,7 @@
 
 case 5:
 YY_RULE_SETUP
-#line 140 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 140 "src/scan-code.l"
 STRING_GROW; BEGIN sc_context;
 	YY_BREAK
 
@@ -1131,7 +1141,7 @@
 
 case 6:
 YY_RULE_SETUP
-#line 145 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 145 "src/scan-code.l"
 STRING_GROW; BEGIN sc_context;
 	YY_BREAK
 
@@ -1139,29 +1149,29 @@
 
 case 7:
 YY_RULE_SETUP
-#line 151 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 151 "src/scan-code.l"
 STRING_GROW; BEGIN SC_CHARACTER;
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 152 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 152 "src/scan-code.l"
 STRING_GROW; BEGIN SC_STRING;
 	YY_BREAK
 case 9:
 /* rule 9 can match eol */
 YY_RULE_SETUP
-#line 153 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 153 "src/scan-code.l"
 STRING_GROW; BEGIN SC_COMMENT;
 	YY_BREAK
 case 10:
 /* rule 10 can match eol */
 YY_RULE_SETUP
-#line 154 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 154 "src/scan-code.l"
 STRING_GROW; BEGIN SC_LINE_COMMENT;
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 156 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 156 "src/scan-code.l"
 {
     complain (loc, Wother, _("stray '%s'"), code_text);
     obstack_escape (&obstack_for_string, code_text);
@@ -1172,7 +1182,7 @@
 
 case 12:
 YY_RULE_SETUP
-#line 164 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 164 "src/scan-code.l"
 {
     ref_tail_fields = NULL;
     handle_action_dollar (self->rule, code_text, *loc);
@@ -1182,7 +1192,7 @@
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 170 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 170 "src/scan-code.l"
 {
     ref_tail_fields = NULL;
     handle_action_at (self->rule, code_text, *loc);
@@ -1195,10 +1205,10 @@
 
 case 14:
 YY_RULE_SETUP
-#line 180 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 180 "src/scan-code.l"
 {
     const char *type_name = NULL;
-    fetch_type_name (code_text + 1, &type_name, *loc)[-1] = 0;
+    fetch_type_name (code_text, &type_name, *loc)[-1] = 0;
     obstack_sgrow (&obstack_for_string, "]b4_dollar_dollar(");
     obstack_quote (&obstack_for_string, type_name);
     obstack_sgrow (&obstack_for_string, ")[");
@@ -1207,7 +1217,7 @@
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 188 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 188 "src/scan-code.l"
 {
     obstack_sgrow (&obstack_for_string, "]b4_at_dollar[");
     muscle_percent_define_ensure("locations", the_location, true);
@@ -1219,14 +1229,14 @@
 /* Escape M4 quoting characters in C code.  */
 case 16:
 YY_RULE_SETUP
-#line 198 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 198 "src/scan-code.l"
 obstack_escape (&obstack_for_string, code_text);
 	YY_BREAK
 /* By default, grow the string obstack with the input.  */
 case 17:
 /* rule 17 can match eol */
 YY_RULE_SETUP
-#line 201 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 201 "src/scan-code.l"
 STRING_GROW;
 	YY_BREAK
 /* End of processing. */
@@ -1237,16 +1247,16 @@
 case YY_STATE_EOF(SC_CHARACTER):
 case YY_STATE_EOF(SC_RULE_ACTION):
 case YY_STATE_EOF(SC_SYMBOL_ACTION):
-#line 204 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 204 "src/scan-code.l"
 STRING_FINISH; return last_string;
 	YY_BREAK
 
 case 18:
 YY_RULE_SETUP
-#line 207 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 207 "src/scan-code.l"
 YY_FATAL_ERROR( "flex scanner jammed" );
 	YY_BREAK
-#line 1250 "src/scan-code.c"
+#line 1260 "src/scan-code.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -1377,6 +1387,7 @@
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
+	} /* end of user's declarations */
 } /* end of code_lex */
 /* %ok-for-header */
 
@@ -1549,7 +1560,7 @@
 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
 /* %% [16.0] code to find the next state goes here */
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 18);
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 19);
 		if ( yy_accept[yy_current_state] )
 			{
 			(yy_last_accepting_state) = yy_current_state;
@@ -1558,7 +1569,7 @@
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 91 )
+			if ( yy_current_state >= 93 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
@@ -1582,7 +1593,7 @@
     /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
 	register char *yy_cp = (yy_c_buf_p);
 
-	register YY_CHAR yy_c = 18;
+	register YY_CHAR yy_c = 19;
 	if ( yy_accept[yy_current_state] )
 		{
 		(yy_last_accepting_state) = yy_current_state;
@@ -1591,11 +1602,11 @@
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 91 )
+		if ( yy_current_state >= 93 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 90);
+	yy_is_jam = (yy_current_state == 92);
 
 		return yy_is_jam ? 0 : yy_current_state;
 }
@@ -2066,7 +2077,7 @@
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
-	int i;
+	yy_size_t i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
 	n = _yybytes_len + 2;
@@ -2326,7 +2337,7 @@
 
 /* %ok-for-header */
 
-#line 207 "/Users/akim/src/gnu/bison/src/scan-code.l"
+#line 207 "src/scan-code.l"
 
 
 
@@ -2890,12 +2901,13 @@
 /*-------------------------.
 | Initialize the scanner.  |
 `-------------------------*/
+//extern char *php_lex (code_props *self, int sc_context);
 
 /* Translate the dollars and ats in \a self, in the context \a sc_context
    (SC_RULE_ACTION, SC_SYMBOL_ACTION, INITIAL).  */
 
-static char const *
-translate_action (code_props *self, int sc_context)
+char const *
+c_translate_action (code_props *self, int sc_context)
 {
   char *res;
   static bool initialized = false;
@@ -2917,7 +2929,7 @@
 /*------------------------------------------------------------------------.
 | Implementation of the public interface as documented in "scan-code.h".  |
 `------------------------------------------------------------------------*/
-
+/*
 void
 code_props_none_init (code_props *self)
 {
@@ -2949,10 +2961,14 @@
 void
 code_props_rule_action_init (code_props *self, char const *code,
                              location code_loc, symbol_list *rule,
-                             named_ref *name, bool is_predicate)
+                             named_ref *name, bool is_predicate, bool translate)
 {
   code_props_none_init (self);
-  self->kind = CODE_PROPS_RULE_ACTION;
+  if (translate) {
+    self->kind = CODE_PROPS_RULE_ACTION;
+  } else {
+    self->kind = CODE_PROPS_NONE;
+  }
   self->code = code;
   self->location = code_loc;
   self->rule = rule;
@@ -2991,7 +3007,7 @@
   obstack_free (&obstack_for_string, 0);
   variant_table_free ();
 
-  /* Reclaim Flex's buffers.  */
+  // Reclaim Flex's buffers.
   code_lex_destroy ();
 }
-
+*/
diff -ruN bison-3.0.4/src/scan-code.h bison-3.0.4b/src/scan-code.h
--- bison-3.0.4/src/scan-code.h	2015-01-16 09:47:42.000000000 -0500
+++ bison-3.0.4b/src/scan-code.h	2015-12-23 21:12:44.250371100 -0500
@@ -157,7 +157,7 @@
  */
 void code_props_rule_action_init (code_props *self, char const *code,
                                   location code_loc, struct symbol_list *rule,
-                                  named_ref *name, bool is_predicate);
+                                  named_ref *name, bool is_predicate, bool translate);
 
 /**
  * \pre
diff -ruN bison-3.0.4/src/scan-code.l bison-3.0.4b/src/scan-code.l
--- bison-3.0.4/src/scan-code.l	2015-01-22 11:04:28.000000000 -0500
+++ bison-3.0.4b/src/scan-code.l	2015-12-30 21:03:37.761104500 -0500
@@ -42,7 +42,7 @@
 
 /* The current calling start condition: SC_RULE_ACTION or
    SC_SYMBOL_ACTION. */
-# define YY_DECL static char *code_lex (code_props *self, int sc_context)
+# define YY_DECL char *code_lex (code_props *self, int sc_context)
 YY_DECL;
 
 #define YY_USER_ACTION  location_compute (loc, &loc->end, yytext, yyleng);
@@ -153,7 +153,7 @@
   "/"{splice}"*"   STRING_GROW; BEGIN SC_COMMENT;
   "/"{splice}"/"   STRING_GROW; BEGIN SC_LINE_COMMENT;
 
-  [$@]  {
+  "$|@"  {
     complain (loc, Wother, _("stray '%s'"), yytext);
     obstack_escape (&obstack_for_string, yytext);
   }
@@ -179,7 +179,7 @@
 {
   "$"("<"{tag}">")?"$" {
     const char *type_name = NULL;
-    fetch_type_name (yytext + 1, &type_name, *loc)[-1] = 0;
+    fetch_type_name (yytext, &type_name, *loc)[-1] = 0;
     obstack_sgrow (&obstack_for_string, "]b4_dollar_dollar(");
     obstack_quote (&obstack_for_string, type_name);
     obstack_sgrow (&obstack_for_string, ")[");
@@ -766,12 +766,13 @@
 /*-------------------------.
 | Initialize the scanner.  |
 `-------------------------*/
+//extern char *php_lex (code_props *self, int sc_context);
 
 /* Translate the dollars and ats in \a self, in the context \a sc_context
    (SC_RULE_ACTION, SC_SYMBOL_ACTION, INITIAL).  */
 
-static char const *
-translate_action (code_props *self, int sc_context)
+char const *
+c_translate_action (code_props *self, int sc_context)
 {
   char *res;
   static bool initialized = false;
@@ -793,7 +794,7 @@
 /*------------------------------------------------------------------------.
 | Implementation of the public interface as documented in "scan-code.h".  |
 `------------------------------------------------------------------------*/
-
+/*
 void
 code_props_none_init (code_props *self)
 {
@@ -825,10 +826,14 @@
 void
 code_props_rule_action_init (code_props *self, char const *code,
                              location code_loc, symbol_list *rule,
-                             named_ref *name, bool is_predicate)
+                             named_ref *name, bool is_predicate, bool translate)
 {
   code_props_none_init (self);
-  self->kind = CODE_PROPS_RULE_ACTION;
+  if (translate) {
+    self->kind = CODE_PROPS_RULE_ACTION;
+  } else {
+    self->kind = CODE_PROPS_NONE;
+  }
   self->code = code;
   self->location = code_loc;
   self->rule = rule;
@@ -867,6 +872,7 @@
   obstack_free (&obstack_for_string, 0);
   variant_table_free ();
 
-  /* Reclaim Flex's buffers.  */
+  // Reclaim Flex's buffers.
   yylex_destroy ();
 }
+*/
\ No newline at end of file
diff -ruN bison-3.0.4/src/scan-gram.c bison-3.0.4b/src/scan-gram.c
--- bison-3.0.4/src/scan-gram.c	2015-01-22 10:58:36.000000000 -0500
+++ bison-3.0.4b/src/scan-gram.c	2015-12-23 22:01:09.087700200 -0500
@@ -36,7 +36,7 @@
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 37
+#define YY_FLEX_SUBMINOR_VERSION 39
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -235,6 +235,7 @@
 #define EOB_ACT_LAST_MATCH 2
 
     #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
     
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
@@ -443,6 +444,8 @@
 extern char *gram_text;
 #define yytext_ptr gram_text
 
+/* %% [1.5] DFA */
+
 /* %if-c-only Standard (non-C++) definition */
 
 static yy_state_type yy_get_previous_state (void );
@@ -465,8 +468,8 @@
 	(yy_c_buf_p) = yy_cp;
 
 /* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
-#define YY_NUM_RULES 130
-#define YY_END_OF_BUFFER 131
+#define YY_NUM_RULES 132
+#define YY_END_OF_BUFFER 133
 /* This struct is not used in this scanner,
    but its presence is necessary. */
 struct yy_trans_info
@@ -474,71 +477,72 @@
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[579] =
+static yyconst flex_int16_t yy_accept[585] =
     {   0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,   93,   93,  113,  113,  113,  113,    0,    0,
-        0,    0,  131,   80,    2,    2,   71,   80,   70,   80,
-        1,   66,   80,   67,   67,   65,   77,   63,   66,   79,
-       73,   64,   80,   90,   90,  128,   95,   94,  128,   81,
-       97,   96,   84,    2,    1,   84,   83,   82,   84,   99,
-       99,  100,   98,   81,  129,  119,  128,  118,  128,  128,
-      128,  122,  125,  126,  128,   92,  128,  117,  116,  128,
-      115,  114,   87,    2,    1,   85,   87,   87,   86,   87,
+        0,    0,    0,    0,   94,   94,  114,  114,  114,  114,
+        0,    0,    0,    0,  133,   81,    2,    2,   71,   81,
+       70,   81,    1,   66,   81,   67,   67,   65,   78,   63,
+       66,   80,   73,   64,   81,   91,   91,  130,   96,   95,
+      130,   82,   98,   97,   85,    2,    1,   85,   84,   83,
+       85,  100,  100,  101,   99,   82,  131,  120,  130,  119,
+      130,  130,  130,  123,  126,  127,  128,  130,   93,  130,
+      118,  117,  130,  116,  115,   88,    2,    1,   86,   88,
 
-       88,    2,    1,   88,   88,   80,   78,   62,    0,   62,
-       62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
-       62,   62,   62,   62,   62,   62,   62,   72,   66,   66,
-        4,    3,   69,   67,   69,    0,   76,    0,   89,  112,
-      110,  101,  112,  103,  104,  105,  106,  107,  108,  112,
-      109,  112,   99,   99,  100,  127,  120,  121,    0,  123,
-        0,  122,  124,    0,   91,    0,    0,   93,  113,  113,
-      113,  113,   87,   85,   62,    0,   74,   62,   62,   62,
+       88,   87,   88,   89,    2,    1,   89,   89,   81,    0,
+       79,   62,    0,   62,   62,   62,   62,   62,   62,   62,
        62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   72,   66,   66,    4,    3,   69,   67,   69,    0,
+       77,    0,   90,  113,  111,  102,  113,  104,  105,  106,
+      107,  108,  109,  113,  110,  113,  100,  100,  101,  129,
+      121,  122,    0,  124,    0,  123,  125,    0,   92,    0,
+        0,   94,  114,  114,  114,  114,   88,   86,    0,   74,
+       62,    0,   75,   62,   62,   62,   62,   62,   62,   62,
        62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
 
-       62,   62,   62,   62,   62,   62,   62,   62,    3,   69,
-       68,   75,    0,  101,    0,    0,  102,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   62,   62,   62,    3,   69,   68,   76,    0,  102,
+        0,    0,  103,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   62,   62,   62,   62,
        62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
        62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
        62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
-       62,   62,   62,   62,   62,   62,   62,   62,    0,  101,
-        0,    0,   62,    7,   62,   62,   62,   62,   62,   62,
-       62,   62,   62,   62,   62,   62,   62,   23,   62,   62,
+       62,   62,   62,   62,    0,  102,    0,    0,   62,    7,
        62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   62,   62,   23,   62,   62,   62,   62,   62,   62,
 
-       62,   62,   36,   62,   62,   62,   62,   62,   62,   44,
-       62,   47,   62,   62,   50,    0,    0,    0,   62,    8,
-       62,   62,   62,   13,   14,   62,   62,   62,   62,   62,
-       62,   62,   62,   62,   26,   62,   62,   62,   62,   62,
-       62,   62,   62,   32,   62,   34,   62,   62,   62,   62,
-       62,   62,   41,   62,   43,   45,   48,   62,    0,    0,
-      111,    6,   62,   10,   62,   62,   62,   16,   62,   62,
+       62,   62,   62,   62,   62,   62,   62,   62,   36,   62,
+       62,   62,   62,   62,   62,   44,   62,   47,   62,   62,
+       50,    0,    0,    0,   62,    8,   62,   62,   62,   13,
+       14,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       26,   62,   62,   62,   62,   62,   62,   62,   62,   32,
+       62,   34,   62,   62,   62,   62,   62,   62,   41,   62,
+       43,   45,   48,   62,    0,    0,  112,    6,   62,   10,
+       62,   62,   62,   16,   62,   62,   62,   62,   62,   62,
        62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
-       62,   62,   62,   62,   33,   62,   62,   62,   62,   62,
-       62,   62,   62,   62,   62,    0,   62,   11,   62,   62,
+       33,   62,   62,   62,   62,   62,   62,   62,   62,   62,
 
+       62,    0,   62,   11,   62,   62,   62,   62,   62,   62,
        62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
-       62,   62,   62,   62,   62,   62,   62,   62,   62,    0,
-       59,   62,   62,   38,   62,   62,   40,   62,   62,   62,
-       49,    5,    0,   62,   62,   62,   62,   62,   62,   62,
-       62,   62,   62,   62,   62,   22,   62,   62,   62,   62,
-       62,   29,   62,   58,   30,   62,   62,   62,   62,   62,
-       42,   62,   62,    0,   62,   62,   62,   62,   62,   17,
-       53,   62,   62,   62,   62,   62,   24,   25,   62,   62,
-       62,   62,   62,   62,   62,   62,   62,   62,   62,    0,
-        0,   62,   62,   12,   62,   62,   62,   62,   62,   21,
-
-       62,   62,   62,   62,   62,   62,   62,   37,   62,   62,
-       62,   62,   62,   62,   62,   62,   18,   62,   62,   62,
-       27,   56,   62,   62,   62,   35,   39,   60,   46,   61,
-        9,   51,   62,   62,    0,   54,   62,   62,   62,    0,
-       56,   62,   62,   62,   15,   52,   62,   62,   62,   62,
-       62,   62,   62,   62,   20,   62,   62,   62,   62,   62,
-       28,   57,   62,   62,   62,   62,   62,   62,   62,   19,
-       55,   62,   62,   62,   62,   62,   31,    0
+       62,   62,   62,   62,   62,    0,   59,   62,   62,   38,
+       62,   62,   40,   62,   62,   62,   49,    5,    0,   62,
+       62,   62,   62,   62,   62,   62,   62,   62,   62,   62,
+       62,   22,   62,   62,   62,   62,   62,   29,   62,   58,
+       30,   62,   62,   62,   62,   62,   42,   62,   62,    0,
+       62,   62,   62,   62,   62,   17,   53,   62,   62,   62,
+       62,   62,   24,   25,   62,   62,   62,   62,   62,   62,
+       62,   62,   62,   62,   62,    0,    0,   62,   62,   12,
+
+       62,   62,   62,   62,   62,   21,   62,   62,   62,   62,
+       62,   62,   62,   37,   62,   62,   62,   62,   62,   62,
+       62,   62,   18,   62,   62,   62,   27,   56,   62,   62,
+       62,   35,   39,   60,   46,   61,    9,   51,   62,   62,
+        0,   54,   62,   62,   62,    0,   56,   62,   62,   62,
+       15,   52,   62,   62,   62,   62,   62,   62,   62,   62,
+       20,   62,   62,   62,   62,   62,   28,   57,   62,   62,
+       62,   62,   62,   62,   62,   19,   55,   62,   62,   62,
+       62,   62,   31,    0
     } ;
 
 static yyconst flex_int32_t yy_ec[256] =
@@ -546,17 +550,17 @@
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         2,    2,    4,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    5,    1,    6,    7,    1,    8,    1,    9,    1,
-        1,   10,    1,   11,   12,   13,   14,   15,   16,   16,
-       16,   16,   16,   16,   16,   17,   17,   18,   19,   20,
-       21,   22,   23,    1,   24,   24,   24,   24,   24,   24,
-       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
-       25,   25,   25,   25,   26,   25,   25,   27,   25,   25,
-       28,   29,   30,    1,   31,    1,   32,   33,   34,   35,
-
-       36,   37,   38,   39,   40,   25,   41,   42,   43,   44,
-       45,   46,   47,   48,   49,   50,   51,   52,   25,   53,
-       54,   25,   55,   56,   57,    1,    1,    1,    1,    1,
+        1,    5,    6,    7,    8,    1,    9,    1,   10,    1,
+        1,   11,    1,   12,   13,   14,   15,   16,   17,   17,
+       17,   17,   17,   17,   17,   18,   18,   19,   20,   21,
+       22,   23,   24,    1,   25,   25,   25,   25,   25,   25,
+       26,   26,   26,   26,   26,   26,   26,   26,   26,   26,
+       26,   26,   26,   26,   27,   26,   26,   28,   26,   26,
+       29,   30,   31,    1,   32,    1,   33,   34,   35,   36,
+
+       37,   38,   39,   40,   41,   26,   42,   43,   44,   45,
+       46,   47,   48,   49,   50,   51,   52,   53,   26,   54,
+       55,   26,   56,   57,   58,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -573,398 +577,406 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst flex_int32_t yy_meta[59] =
+static yyconst flex_int32_t yy_meta[60] =
     {   0,
-        1,    2,    3,    1,    2,    4,    1,    4,    4,    4,
-        4,    5,    6,    2,    7,    7,    7,    1,    4,    8,
-        4,    8,    1,    7,    9,    9,    9,   10,    1,   11,
-        9,    7,    7,    7,    7,    7,    7,    9,    9,    9,
+        1,    2,    3,    1,    2,    1,    4,    1,    4,    4,
+        4,    4,    5,    6,    2,    7,    7,    7,    1,    4,
+        8,    4,    8,    1,    7,    9,    9,    9,   10,    1,
+       11,    9,    7,    7,    7,    7,    7,    7,    9,    9,
         9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-        9,    9,    9,    9,    4,    4,    4,    1
+        9,    9,    9,    9,    9,    4,    4,    4,    1
     } ;
 
-static yyconst flex_int16_t yy_base[605] =
+static yyconst flex_int16_t yy_base[611] =
     {   0,
-        0, 1001,  997,  996,   56,   57,   58,   61,   63,   90,
-       76,   87,   70,   97,  117,  121,   66,  130,  140,  144,
-       79,  107,   99,  109,  153,  159,  148,  152,  201,  998,
-      182,  258, 1004,    0, 1009, 1009, 1009,  265, 1009, 1009,
-     1009,  320,  153,  313,  153, 1009,   61, 1009,  330, 1009,
-     1009, 1009,  961, 1009,  988, 1009, 1009, 1009,  383, 1009,
-     1009, 1009, 1009, 1009, 1009,  161, 1009, 1009,  959,  988,
-      110,  979, 1009,  986, 1009, 1009,  940, 1009,  169,  144,
-      254, 1009, 1009, 1009,  250, 1009,  187, 1009, 1009,  265,
-     1009, 1009,    0, 1009,    0,    0,  261, 1009, 1009,  954,
-
-     1009, 1009, 1009,  266,  953,    0, 1009,    0,  320,  954,
-      948,  241,  293,  952,  949,  946,  250,  953,  294,  937,
-      303,  245,  150,  311,  943,  950,  953, 1009,  436,    0,
-     1009,    0,    0,  346,  480,  962, 1009,  943, 1009, 1009,
-     1009,  342,    0, 1009, 1009, 1009, 1009, 1009, 1009,    0,
-     1009,    0,  970,  330,  961, 1009, 1009, 1009,  365, 1009,
-      369, 1009, 1009,  374, 1009,  378,  382,  951, 1009,  388,
-      950,  392,    0,    0,    0,  398, 1009,  934,  942,  374,
-      928,  929,  926,  927,  360,  924,  931,  926,  368,  935,
-      920,  924,  398,  930,  915,  916,  333,  915,  915,  923,
-
-      924,  927,  910,  916,  910,  915,  906,  919,    0,    0,
-        0, 1009,  908,  402,    0,    0,    0,  423,  431,  453,
-      410,  459,  443,  465,  390,  471,  475,  479,  483,  379,
-      919,  914,  898,   81,  898,  911,  896,  900,  908,  907,
-      906,  929,  890,  901,  888,  925,  904,  897,  898,  415,
-      448,  412,  885,  886,  420,  897,  886,  893,  877,  888,
-      884,  877,  881,  887,  886,  876,  887,  885,  882, 1009,
-        0,    0,  869,    0,  878,  864,  870,  865,  878,  857,
-      862,  875,  896,  872,  860,  865,  853,    0,  857,  852,
-      865,  333,  864,  859,  862,  857,  847,  859,  851,  842,
-
-      849,  855,  854,  839,  467,  848,  837,  850,  835,    0,
-      840,    0,  839,  837,    0,  876,    0,    0,  826,    0,
-      837,  842,  826,    0,    0,  475,  826,  829,  477,  842,
-      841,  840,  839,  830,    0,  823,  822,  830,  822,  828,
-      820,  814,  812,    0,  811,    0,  848,  824,  822,  811,
-      810,  807,    0,  804,    0,  479,    0,  804,  484,    0,
-     1009,    0,  802,  802,  816,  797,  796,  480,  799,  801,
-      800,  796,  801,  804,  793,  795,  791,  790,  805,  800,
-      803,  798,  788,  796,  516,  785,  794,  781,  796,  795,
-      790,  780,  774,  773,  786,  519,  495,    0,  771,  784,
-
-      783,  770,  769,  780,  764,  763,  764,  800,  775,  778,
-      765,  772,  771,  755,  756,  753,  754,  768,  753,  525,
-     1009,  768,  755,    0,  750,  749,    0,  752,  763,  762,
-        0, 1009,  787,  746,  745,  745,  741,  740,  739,  738,
-      748,  734,  733,  746,  749,    0,  737,  730,  741,  740,
-      734,    0,  733,    0,    0,  731,  725,  738,  722,  721,
-        0,  736,  735,  761,  718,  717,  716,  730,  729,    0,
-        0,  721,  714,  713,  710,  723,    0,    0,  716,  715,
-      704,  703,  712,  719,  714,  705,  701,  683,  679,  710,
-      499,  675,  673,    0,  663,  660,  651,  639,  619,    0,
-
-      616,  611,  607,  511,  513,  615,  615,    0,  607,  606,
-      617,  616,  615,  614,  598,  540,  536,  538,  537,  546,
-      545,  549,  539,  538,  543,    0,    0,    0,    0,    0,
-        0,    0,  546,  545,  556, 1009,  531,  533,  535,  569,
-     1009,  531,  530,  527,    0,    0,  538,  532,  524,  531,
-      529,  513,  516,  515,    0,  499,  498,  491,  467,  461,
-        0,    0,  459,  439,  435,  434,  389,  381,  378,    0,
-        0,  390,  366,  347,  350,  307,    0, 1009,  590,  601,
-      612,  623,  634,  645,  656,  662,  671,  682,  693,  702,
-      708,  713,  722,  729,  286,  277,  259,  187,  179,  173,
+        0, 1030, 1026, 1025,   57,   58,   59,   60,   79,   94,
+       53,   62,  117,  126,  135,  144,  154,  163,  100,  145,
+      173,  194,   68,   69,   65,   70,   98,  155,  101,  176,
+      252, 1027,  193,  215, 1034,    0, 1039, 1039, 1039,  306,
+     1039, 1039, 1039,  362,  119,  355,  208, 1039,  114, 1039,
+      421, 1039, 1039, 1039,  990, 1039, 1017, 1039, 1039, 1039,
+      474, 1039, 1039, 1039, 1039, 1039, 1039,  128, 1039, 1039,
+      988, 1017,   54, 1008, 1039, 1015, 1039, 1039,  969, 1039,
+      217,   63,  213, 1039, 1039, 1039, 1039,  159, 1039,  211,
+     1039, 1039,  375, 1039, 1039,    0, 1039,    0,    0,  156,
+
+     1039, 1039,  983, 1039, 1039, 1039,  166,  982,    0,  311,
+     1039,    0,  323,  983,  977,  198,  192,  981,  978,  975,
+      205,  982,  336,  966,  351,  170,   98,  281,  972,  979,
+      982, 1039,  528,    0, 1039,    0,    0,  305,  572,  991,
+     1039,  972, 1039, 1039, 1039,  223,    0, 1039, 1039, 1039,
+     1039, 1039, 1039,    0, 1039,    0,  999,  306,  990, 1039,
+     1039, 1039,  386, 1039,  392, 1039, 1039,  396, 1039,  405,
+      409,  980, 1039,  413,  979,  421,    0,    0,  429, 1039,
+        0,  433, 1039,  963,  971,  199,  957,  958,  955,  956,
+      281,  953,  960,  955,  336,  964,  949,  953,  372,  959,
+
+      944,  945,  207,  944,  944,  952,  953,  956,  939,  945,
+      939,  944,  935,  948,    0,    0,    0, 1039,  937,  348,
+        0,    0,    0,  439,  428,  444,  169,  451,  439,  459,
+      398,  463,  468,  472,  490,  403,  948,  943,  927,   81,
+      927,  940,  925,  929,  937,  936,  935,  958,  919,  930,
+      917,  954,  933,  926,  927,  394,  414,  154,  914,  915,
+      369,  926,  915,  922,  906,  917,  913,  906,  910,  916,
+      915,  905,  916,  914,  911, 1039,    0,    0,  898,    0,
+      907,  893,  899,  894,  907,  886,  891,  904,  925,  901,
+      889,  894,  882,    0,  886,  881,  894,  446,  893,  888,
+
+      891,  886,  876,  888,  880,  871,  878,  884,  883,  868,
+      450,  877,  866,  879,  864,    0,  869,    0,  868,  866,
+        0,  906,    0,    0,  855,    0,  866,  871,  855,    0,
+        0,  454,  855,  858,  470,  871,  870,  869,  868,  859,
+        0,  852,  851,  859,  851,  857,  849,  843,  841,    0,
+      840,    0,  877,  853,  851,  840,  839,  836,    0,  833,
+        0,  474,    0,  833,  493,    0, 1039,    0,  831,  831,
+      845,  826,  825,  481,  828,  830,  829,  825,  830,  833,
+      822,  824,  820,  819,  834,  829,  832,  827,  817,  825,
+      513,  814,  823,  810,  825,  824,  819,  809,  803,  802,
+
+      815,  528,  490,    0,  800,  813,  812,  799,  798,  809,
+      793,  792,  793,  829,  804,  807,  794,  801,  800,  784,
+      785,  782,  783,  797,  782,  535, 1039,  797,  784,    0,
+      779,  778,    0,  781,  792,  791,    0, 1039,  816,  775,
+      774,  774,  770,  769,  768,  767,  777,  763,  762,  775,
+      778,    0,  766,  759,  770,  769,  763,    0,  762,    0,
+        0,  760,  754,  767,  751,  750,    0,  765,  764,  790,
+      747,  746,  745,  759,  758,    0,    0,  750,  743,  742,
+      739,  752,    0,    0,  745,  744,  733,  732,  741,  748,
+      743,  742,  741,  726,  722,  746,  469,  712,  707,    0,
+
+      693,  691,  682,  681,  680,    0,  667,  644,  640,  492,
+      517,  647,  644,    0,  638,  637,  646,  645,  646,  645,
+      627,  626,  551,  624,  566,  575,  558,  562,  568,  567,
+      572,    0,    0,    0,    0,    0,    0,    0,  575,  574,
+      572, 1039,  537,  538,  558,  596, 1039,  554,  553,  546,
+        0,    0,  557,  555,  547,  554,  549,  534,  542,  541,
+        0,  546,  544,  537,  529,  528,    0,    0,  533,  511,
+      506,  508,  470,  464,  453,    0,    0,  466,  448,  446,
+      451,  430,    0, 1039,  618,  629,  640,  651,  662,  673,
+      684,  690,  699,  710,  721,  730,  736,  741,  750,  757,
 
-      135,  133,   87,  738
+      448,  413,  389,  330,  310,  161,  139,   85,   71,  766
     } ;
 
-static yyconst flex_int16_t yy_def[605] =
+static yyconst flex_int16_t yy_def[611] =
     {   0,
-      578,    1,  579,  579,  580,  580,  580,  580,  581,  581,
-      582,  582,  580,  580,  580,  580,  580,  580,  580,  580,
-      580,  580,  580,  580,  580,  580,  580,  580,  578,   29,
-      583,  583,  578,  584,  578,  578,  578,  578,  578,  578,
-      578,  585,  578,  586,  586,  578,  578,  578,  585,  578,
-      578,  578,  584,  578,  578,  578,  578,  578,  587,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  588,
-      588,  578,  578,  588,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  589,
-      578,  578,  590,  578,  590,  591,  578,  578,  578,  590,
-
-      578,  578,  578,  578,  578,  584,  578,  592,  578,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  578,  585,   49,
-      578,  593,  594,  586,  594,  578,  578,  578,  578,  578,
-      578,  578,  595,  578,  578,  578,  578,  578,  578,  596,
-      578,  597,  588,  588,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  590,  591,  592,  578,  578,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-
-      592,  592,  592,  592,  592,  592,  592,  592,  593,  594,
-      135,  578,  578,  578,  598,  599,  597,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  589,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  578,  578,
-      600,  601,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  578,  602,  603,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  578,  596,
-      578,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  578,  592,  592,  592,  592,
-
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  578,
-      578,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  578,  578,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  604,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  604,
-      604,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  578,  578,  592,  592,  592,  578,
-      578,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
-      592,  592,  592,  592,  592,  592,  592,    0,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
+      584,    1,  585,  585,  586,  586,  586,  586,  587,  587,
+      588,  588,  586,  586,  586,  586,  586,  586,  586,  586,
+      586,  586,  586,  586,  586,  586,  586,  586,  586,  586,
+      584,   31,  589,  589,  584,  590,  584,  584,  584,  584,
+      584,  584,  584,  591,  584,  592,  592,  584,  584,  584,
+      591,  584,  584,  584,  590,  584,  584,  584,  584,  584,
+      593,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  594,  594,  584,  584,  594,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  595,  584,  584,  596,  584,  596,  597,  584,
+
+      584,  584,  596,  584,  584,  584,  584,  584,  590,  584,
+      584,  598,  584,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  584,  591,   51,  584,  599,  600,  592,  600,  584,
+      584,  584,  584,  584,  584,  584,  601,  584,  584,  584,
+      584,  584,  584,  602,  584,  603,  594,  594,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  596,  597,  584,  584,
+      598,  584,  584,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  599,  600,  139,  584,  584,  584,
+      604,  605,  603,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  595,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  584,  584,  606,  607,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  584,  608,  609,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  584,  602,  584,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+
+      598,  584,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  584,  584,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  584,  584,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  610,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  610,  610,  598,  598,  598,
+
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      584,  584,  598,  598,  598,  584,  584,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+      598,  598,  598,    0,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
 
-      578,  578,  578,  578
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584
     } ;
 
-static yyconst flex_int16_t yy_nxt[1068] =
+static yyconst flex_int16_t yy_nxt[1099] =
     {   0,
-       34,   35,   36,   34,   35,   37,   34,   38,   39,   40,
-       41,   34,   42,   43,   44,   45,   45,   34,   46,   47,
-       48,   40,   34,   49,   49,   49,   49,   50,   34,   34,
-       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
-       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
-       49,   49,   49,   49,   51,   52,   40,   34,   57,   57,
-       61,   58,   58,   61,   64,   36,   62,   64,   75,   62,
-      136,   76,   75,   65,   78,   76,   66,   77,   78,   79,
-       67,   75,  137,   79,   59,   59,   59,   71,   85,   59,
-       68,   64,   36,  361,   64,   72,   69,   73,   71,   75,
-
-       65,   86,   76,   66,   77,   78,   72,   67,   73,   75,
-       79,   86,  276,   60,   60,   60,   85,   68,   60,   75,
-      277,  154,   76,   75,   80,   78,   76,   87,   80,   78,
-       79,  153,   75,   74,   79,   76,   81,   87,   78,  360,
-       81,  318,   75,   79,   74,   76,   75,   80,   78,   76,
-       91,   80,   78,   79,   91,   88,   92,   79,   89,   81,
-       92,   88,  131,   81,   89,  160,  132,  134,  134,  134,
-      131,   82,  161,   83,  132,   82,   90,   83,  157,  317,
-       90,   90,  158,  102,   36,  272,  102,   90,  167,  168,
-      201,  167,  103,  271,   82,  104,   84,  159,   82,  202,
-
-       84,   93,   94,   36,   93,   94,   93,   93,   93,   93,
-       93,   95,   93,   96,   97,   98,   98,   98,   93,   93,
-       93,   93,   93,   93,   96,   96,   96,   96,   93,   93,
-       99,   96,   96,   96,   96,   96,   96,   96,   96,   96,
-       96,   96,   96,   96,   96,   96,   96,   96,   96,   96,
-       96,   96,   96,   96,   96,   93,   93,   93,   93,  102,
-       36,  162,  102,  165,  105,  217,  170,  171,  103,  170,
-      131,  104,  107,  163,  132,  131,  180,  108,  166,  132,
-      199,  188,  164,  216,  200,  189,  181,  109,  108,  108,
-      108,  108,  215,  172,  190,  108,  108,  110,  111,  112,
-
-      113,  114,  115,  108,  116,  108,  117,  118,  119,  120,
-      121,  108,  122,  123,  124,  125,  126,  108,  127,  128,
-      106,  176,  176,  106,  176,  192,  106,  134,  134,  134,
-      578,  129,  129,  578,  196,  182,  578,  106,  193,  135,
-      183,  154,  106,  194,  336,  184,  203,  578,  106,  106,
-      197,  153,  578,  198,  577,  204,  214,  214,  578,  578,
-      134,  134,  134,  337,  205,  135,  218,  219,  256,  218,
-      220,  221,  257,  220,  177,  222,  223,  106,  222,  224,
-      225,  578,  224,  167,  168,  576,  167,  578,  141,  227,
-      171,  141,  227,  229,  230,  575,  229,  142,  142,  176,
-
-      176,  240,  176,  165,  245,  141,  233,  172,  143,  250,
-      234,  141,  241,  574,  144,  145,  270,  270,  166,  146,
-      246,  573,  235,  572,  218,  219,  147,  218,  251,  571,
-      148,  160,  149,  150,  151,  152,  106,  570,  161,  106,
-      157,  252,  106,  297,  158,  569,  298,  129,  129,  293,
-      162,  301,  177,  106,  220,  221,  294,  220,  106,  159,
-      222,  223,  163,  222,  106,  106,  224,  225,  302,  224,
-      568,  164,  167,  168,  567,  167,  227,  171,  350,  227,
-      227,  171,  295,  227,  229,  230,  366,  229,  370,  296,
-      393,  402,  566,  106,  211,  211,  211,  351,  396,  396,
-
-      396,  432,  565,  211,  491,  367,  434,  371,  564,  394,
-      403,  211,  211,  211,  211,  211,  211,  420,  420,  420,
-      420,  432,  523,  433,  524,  435,  420,  420,  420,  420,
-      563,  562,  561,  396,  396,  396,  421,  535,  535,  535,
-      535,  524,  547,  524,  548,  421,  540,  540,  540,  540,
-      540,  540,  540,  540,  560,  559,  536,  535,  535,  535,
-      535,  548,  558,  548,  557,  541,  556,  555,  554,  541,
-      540,  540,  540,  540,  553,  552,  536,  551,  550,  549,
-      546,  545,  544,  543,  542,  539,  538,  537,  534,  541,
-       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
-
-       54,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   63,   63,   63,   63,   63,   63,   63,   63,
-       63,   63,   63,   70,   70,   70,   70,   70,   70,   70,
-       70,   70,   70,   70,  101,  101,  101,  101,  101,  101,
-      101,  101,  101,  101,  101,  106,  533,  532,  531,  106,
-      106,  530,  529,  528,  527,  106,  130,  526,  525,  522,
-      130,  130,  130,  521,  130,  520,  130,  133,  133,  519,
-      133,  140,  140,  140,  140,  140,  140,  140,  140,  140,
-      140,  140,  153,  153,  153,  153,  153,  153,  153,  518,
-      153,  153,  153,  169,  169,  169,  169,  169,  169,  169,
-
-      169,  169,  173,  517,  516,  173,  173,  515,  514,  173,
-      513,  173,  174,  174,  174,  491,  174,  175,  175,  175,
-      512,  175,  209,  209,  511,  209,  209,  209,  209,  209,
-      209,  209,  209,  210,  210,  210,  510,  210,  490,  490,
-      509,  490,  490,  490,  490,  490,  490,  490,  490,  508,
-      507,  506,  505,  504,  503,  502,  501,  500,  499,  498,
-      497,  496,  495,  494,  493,  492,  491,  489,  488,  487,
-      486,  485,  484,  483,  482,  481,  480,  479,  478,  477,
-      476,  475,  474,  473,  472,  471,  470,  469,  468,  467,
-      466,  465,  464,  463,  462,  461,  460,  459,  458,  457,
-
-      456,  455,  454,  453,  452,  451,  450,  449,  448,  447,
-      446,  445,  444,  443,  442,  441,  440,  439,  438,  437,
-      436,  431,  430,  429,  428,  427,  426,  425,  424,  423,
-      422,  419,  418,  417,  416,  415,  414,  413,  412,  411,
-      410,  409,  408,  407,  406,  405,  404,  401,  400,  399,
-      398,  397,  395,  392,  391,  390,  389,  388,  387,  386,
-      385,  384,  383,  382,  381,  380,  379,  378,  377,  376,
-      375,  374,  373,  372,  369,  368,  365,  364,  363,  362,
-      359,  358,  357,  356,  355,  354,  353,  352,  349,  348,
-      347,  346,  345,  344,  343,  342,  341,  340,  339,  338,
-
-      335,  334,  333,  332,  331,  330,  329,  328,  327,  326,
-      325,  324,  323,  322,  321,  320,  319,  316,  315,  314,
-      313,  312,  311,  310,  309,  308,  307,  306,  305,  304,
-      303,  300,  299,  292,  291,  290,  289,  288,  287,  286,
-      285,  284,  283,  282,  281,  280,  279,  278,  275,  274,
-      273,  269,  268,  267,  266,  265,  264,  263,  262,  261,
-      260,  259,  258,  255,  254,  253,  249,  248,  247,  244,
-      243,  242,  239,  238,  237,  236,  232,  231,  228,  226,
-      155,  154,  213,  212,  208,  207,  206,  195,  191,  187,
-      186,  185,  179,  178,  138,  138,  156,  154,  155,  154,
-
-      138,  139,  138,  578,  100,   55,   55,   53,   33,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578
+       36,   37,   38,   36,   37,   36,   39,   36,   40,   41,
+       42,   43,   36,   44,   45,   46,   47,   47,   36,   48,
+       49,   50,   42,   36,   51,   51,   51,   51,   52,   36,
+       36,   51,   51,   51,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   53,   54,   42,   36,   59,
+       59,   63,   63,   60,   60,   73,  158,   89,   64,   64,
+       77,   77,   89,   74,   73,   75,  157,  367,   88,   88,
+       66,   38,   74,   66,   75,  164,   61,   61,   61,   61,
+       67,  366,  165,   68,   90,   66,   38,   69,   66,   90,
+
+       91,   71,   77,   94,   92,   67,   78,   70,   68,   80,
+       95,   76,   69,  282,   81,   62,   62,   62,   62,   77,
+       76,  283,   70,   78,  140,   79,   80,   93,   77,  135,
+       93,   81,   78,  136,   79,   80,  141,   77,  135,  207,
+       81,   78,  136,   82,   80,  324,   77,   77,  208,   81,
+       78,   78,   82,   80,   80,   83,   77,   91,   81,   81,
+       78,   92,   82,   80,   83,   77,  135,  323,   81,   78,
+      136,   82,   80,  169,   83,   77,  135,   81,   94,   78,
+      136,   82,   80,   83,   93,   95,  303,   81,  170,  304,
+       84,  164,   85,   83,  105,   38,   77,  105,  165,   84,
+
+       78,   85,   82,   80,  106,   93,  205,  107,   81,   84,
+      206,   86,  171,  172,   83,  171,  105,   38,   84,  105,
+       86,  166,  108,  138,  138,  138,  106,  161,   84,  107,
+       87,  162,  239,  167,  186,  188,  240,  194,  220,  220,
+      189,  195,  168,  262,  187,  190,  163,  263,  241,   84,
+      196,   87,   96,   97,   38,   96,   97,   96,   96,   96,
+       96,   96,   96,   98,   96,   99,  100,  101,  101,  101,
+       96,   96,   96,   96,   96,   96,   99,   99,   99,   99,
+       96,   96,  102,   99,   99,   99,   99,   99,   99,   99,
+       99,   99,   99,   99,   99,   99,   99,   99,   99,   99,
+
+       99,   99,   99,   99,   99,   99,   99,   96,   96,   96,
+       96,  110,  179,  179,  111,  179,  278,  209,  158,  112,
+      138,  138,  138,  246,  182,  182,  210,  182,  157,  113,
+      112,  112,  112,  112,  247,  211,  277,  112,  112,  114,
+      115,  116,  117,  118,  119,  112,  120,  112,  121,  122,
+      123,  124,  125,  112,  126,  127,  128,  129,  130,  112,
+      131,  132,  109,  276,  276,  109,  180,  109,  198,  109,
+      138,  138,  138,  251,  133,  133,  174,  175,  183,  174,
+      109,  199,  139,  202,  256,  109,  200,  224,  225,  252,
+      224,  109,  109,  226,  227,  223,  226,  228,  229,  203,
+
+      228,  307,  204,  257,  176,  584,  230,  231,  139,  230,
+      171,  172,  169,  171,  233,  175,  258,  233,  308,  222,
+      109,  584,  235,  236,  584,  235,  584,  170,  584,  299,
+      179,  179,  176,  179,  182,  182,  300,  182,  161,  584,
+      224,  225,  162,  224,  584,  226,  227,  166,  226,  301,
+      584,  584,  228,  229,  221,  228,  302,  163,  342,  167,
+      230,  231,  356,  230,  171,  172,  372,  171,  168,  233,
+      175,  438,  233,  233,  175,  497,  233,  343,  583,  584,
+      145,  357,  376,  145,  180,  373,  399,  582,  183,  146,
+      146,  235,  236,  408,  235,  581,  580,  145,  579,  578,
+
+      147,  377,  440,  145,  529,  400,  148,  149,  402,  402,
+      402,  150,  409,  577,  426,  426,  426,  426,  151,  576,
+      575,  441,  152,  530,  153,  154,  155,  156,  109,  530,
+      438,  109,  439,  109,  427,  109,  426,  426,  426,  426,
+      133,  133,  574,  402,  402,  402,  109,  573,  530,  553,
+      554,  109,  541,  541,  541,  541,  427,  109,  109,  546,
+      546,  546,  546,  546,  546,  546,  546,  572,  554,  554,
+      571,  570,  542,  541,  541,  541,  541,  569,  568,  547,
+      567,  566,  565,  547,  564,  563,  109,  217,  217,  217,
+      562,  561,  560,  542,  559,  558,  217,  546,  546,  546,
+
+      546,  557,  556,  555,  217,  217,  217,  217,  217,  217,
+      552,  551,  550,  549,  548,  545,  544,  547,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
+       65,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,  104,  104,  104,  104,  104,  104,  104,  104,
+      104,  104,  104,  109,  543,  540,  539,  109,  109,  538,
+      537,  536,  535,  109,  134,  534,  533,  532,  134,  134,
+      134,  531,  134,  528,  134,  137,  137,  527,  137,  144,
+
+      144,  144,  144,  144,  144,  144,  144,  144,  144,  144,
+      157,  157,  157,  157,  157,  157,  157,  526,  157,  157,
+      157,  173,  173,  173,  173,  173,  173,  173,  173,  173,
+      177,  525,  524,  177,  177,  523,  522,  177,  521,  177,
+      178,  178,  178,  520,  178,  181,  181,  181,  519,  181,
+      215,  215,  497,  215,  215,  215,  215,  215,  215,  215,
+      215,  216,  216,  216,  518,  216,  496,  496,  517,  496,
+      496,  496,  496,  496,  496,  496,  496,  516,  515,  514,
+      513,  512,  511,  510,  509,  508,  507,  506,  505,  504,
+      503,  502,  501,  500,  499,  498,  497,  495,  494,  493,
+
+      492,  491,  490,  489,  488,  487,  486,  485,  484,  483,
+      482,  481,  480,  479,  478,  477,  476,  475,  474,  473,
+      472,  471,  470,  469,  468,  467,  466,  465,  464,  463,
+      462,  461,  460,  459,  458,  457,  456,  455,  454,  453,
+      452,  451,  450,  449,  448,  447,  446,  445,  444,  443,
+      442,  437,  436,  435,  434,  433,  432,  431,  430,  429,
+      428,  425,  424,  423,  422,  421,  420,  419,  418,  417,
+      416,  415,  414,  413,  412,  411,  410,  407,  406,  405,
+      404,  403,  401,  398,  397,  396,  395,  394,  393,  392,
+      391,  390,  389,  388,  387,  386,  385,  384,  383,  382,
+
+      381,  380,  379,  378,  375,  374,  371,  370,  369,  368,
+      365,  364,  363,  362,  361,  360,  359,  358,  355,  354,
+      353,  352,  351,  350,  349,  348,  347,  346,  345,  344,
+      341,  340,  339,  338,  337,  336,  335,  334,  333,  332,
+      331,  330,  329,  328,  327,  326,  325,  322,  321,  320,
+      319,  318,  317,  316,  315,  314,  313,  312,  311,  310,
+      309,  306,  305,  298,  297,  296,  295,  294,  293,  292,
+      291,  290,  289,  288,  287,  286,  285,  284,  281,  280,
+      279,  275,  274,  273,  272,  271,  270,  269,  268,  267,
+      266,  265,  264,  261,  260,  259,  255,  254,  253,  250,
+
+      249,  248,  245,  244,  243,  242,  238,  237,  234,  232,
+      159,  158,  219,  218,  214,  213,  212,  201,  197,  193,
+      192,  191,  185,  184,  142,  142,  160,  158,  159,  158,
+      142,  143,  142,  584,  103,   57,   57,   55,   35,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584
+
     } ;
 
-static yyconst flex_int16_t yy_chk[1068] =
+static yyconst flex_int16_t yy_chk[1099] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    5,    6,
-        7,    5,    6,    8,    9,    9,    7,    9,   17,    8,
-       47,   17,   13,    9,   17,   13,    9,   13,   13,   17,
-        9,   21,   47,   13,    5,    6,    7,   11,   21,    8,
-        9,   10,   10,  603,   10,   11,   10,   11,   12,   14,
-
-       10,   23,   14,   10,   14,   14,   12,   10,   12,   22,
-       14,   24,  234,    5,    6,    7,   22,   10,    8,   15,
-      234,   71,   15,   16,   15,   15,   16,   23,   16,   16,
-       15,   71,   18,   11,   16,   18,   15,   24,   18,  602,
-       16,  601,   19,   18,   12,   19,   20,   19,   19,   20,
-       27,   20,   20,   19,   28,   25,   27,   20,   25,   19,
-       28,   26,   43,   20,   26,   80,   43,   45,   45,   45,
-       66,   15,   80,   15,   66,   16,   27,   16,   79,  600,
-       28,   25,   79,   31,   31,  599,   31,   26,   87,   87,
-      123,   87,   31,  598,   19,   31,   19,   79,   20,  123,
-
-       20,   29,   29,   29,   29,   29,   29,   29,   29,   29,
-       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
-       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
-       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
-       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
-       29,   29,   29,   29,   29,   29,   29,   29,   29,   32,
-       32,   81,   32,   85,   32,  597,   90,   90,   32,   90,
-       97,   32,   38,   81,   97,  104,  112,   38,   85,  104,
-      122,  117,   81,  596,  122,  117,  112,   38,   38,   38,
-       38,   38,  595,   90,  117,   38,   38,   38,   38,   38,
-
-       38,   38,   38,   38,   38,   38,   38,   38,   38,   38,
-       38,   38,   38,   38,   38,   38,   38,   38,   38,   38,
-       42,  109,  109,   42,  109,  119,   42,   44,   44,   44,
-       49,   42,   42,   49,  121,  113,   49,   42,  119,   44,
-      113,  154,   42,  119,  292,  113,  124,   49,   42,   42,
-      121,  154,   49,  121,  576,  124,  142,  142,   49,   49,
-      134,  134,  134,  292,  124,   44,  159,  159,  197,  159,
-      161,  161,  197,  161,  109,  164,  164,   42,  164,  166,
-      166,  230,  166,  167,  167,  575,  167,   49,   59,  170,
-      170,   59,  170,  172,  172,  574,  172,   59,   59,  176,
-
-      176,  185,  176,  225,  189,   59,  180,  230,   59,  193,
-      180,   59,  185,  573,   59,   59,  214,  214,  225,   59,
-      189,  572,  180,  569,  218,  218,   59,  218,  193,  568,
-       59,  221,   59,   59,   59,   59,  129,  567,  221,  129,
-      219,  193,  129,  252,  219,  566,  252,  129,  129,  250,
-      223,  255,  176,  129,  220,  220,  250,  220,  129,  219,
-      222,  222,  223,  222,  129,  129,  224,  224,  255,  224,
-      565,  223,  226,  226,  564,  226,  227,  227,  305,  227,
-      228,  228,  251,  228,  229,  229,  326,  229,  329,  251,
-      356,  368,  563,  129,  135,  135,  135,  305,  359,  359,
-
-      359,  491,  560,  135,  491,  326,  397,  329,  559,  356,
-      368,  135,  135,  135,  135,  135,  135,  385,  385,  385,
-      385,  396,  504,  396,  505,  397,  420,  420,  420,  420,
-      558,  557,  556,  396,  396,  396,  385,  517,  517,  517,
-      517,  504,  537,  505,  538,  420,  521,  521,  521,  521,
-      522,  522,  522,  522,  554,  553,  517,  535,  535,  535,
-      535,  537,  552,  538,  551,  521,  550,  549,  548,  522,
-      540,  540,  540,  540,  547,  544,  535,  543,  542,  539,
-      534,  533,  525,  524,  523,  520,  519,  518,  516,  540,
-      579,  579,  579,  579,  579,  579,  579,  579,  579,  579,
-
-      579,  580,  580,  580,  580,  580,  580,  580,  580,  580,
-      580,  580,  581,  581,  581,  581,  581,  581,  581,  581,
-      581,  581,  581,  582,  582,  582,  582,  582,  582,  582,
-      582,  582,  582,  582,  583,  583,  583,  583,  583,  583,
-      583,  583,  583,  583,  583,  584,  515,  514,  513,  584,
-      584,  512,  511,  510,  509,  584,  585,  507,  506,  503,
-      585,  585,  585,  502,  585,  501,  585,  586,  586,  499,
-      586,  587,  587,  587,  587,  587,  587,  587,  587,  587,
-      587,  587,  588,  588,  588,  588,  588,  588,  588,  498,
-      588,  588,  588,  589,  589,  589,  589,  589,  589,  589,
-
-      589,  589,  590,  497,  496,  590,  590,  495,  493,  590,
-      492,  590,  591,  591,  591,  490,  591,  592,  592,  592,
-      489,  592,  593,  593,  488,  593,  593,  593,  593,  593,
-      593,  593,  593,  594,  594,  594,  487,  594,  604,  604,
-      486,  604,  604,  604,  604,  604,  604,  604,  604,  485,
-      484,  483,  482,  481,  480,  479,  476,  475,  474,  473,
-      472,  469,  468,  467,  466,  465,  464,  463,  462,  460,
-      459,  458,  457,  456,  453,  451,  450,  449,  448,  447,
-      445,  444,  443,  442,  441,  440,  439,  438,  437,  436,
-      435,  434,  433,  430,  429,  428,  426,  425,  423,  422,
-
-      419,  418,  417,  416,  415,  414,  413,  412,  411,  410,
-      409,  408,  407,  406,  405,  404,  403,  402,  401,  400,
-      399,  395,  394,  393,  392,  391,  390,  389,  388,  387,
-      386,  384,  383,  382,  381,  380,  379,  378,  377,  376,
-      375,  374,  373,  372,  371,  370,  369,  367,  366,  365,
-      364,  363,  358,  354,  352,  351,  350,  349,  348,  347,
-      345,  343,  342,  341,  340,  339,  338,  337,  336,  334,
-      333,  332,  331,  330,  328,  327,  323,  322,  321,  319,
-      316,  314,  313,  311,  309,  308,  307,  306,  304,  303,
-      302,  301,  300,  299,  298,  297,  296,  295,  294,  293,
-
-      291,  290,  289,  287,  286,  285,  284,  283,  282,  281,
-      280,  279,  278,  277,  276,  275,  273,  269,  268,  267,
-      266,  265,  264,  263,  262,  261,  260,  259,  258,  257,
-      256,  254,  253,  249,  248,  247,  246,  245,  244,  243,
-      242,  241,  240,  239,  238,  237,  236,  235,  233,  232,
-      231,  213,  208,  207,  206,  205,  204,  203,  202,  201,
-      200,  199,  198,  196,  195,  194,  192,  191,  190,  188,
-      187,  186,  184,  183,  182,  181,  179,  178,  171,  168,
-      155,  153,  138,  136,  127,  126,  125,  120,  118,  116,
-      115,  114,  111,  110,  105,  100,   77,   74,   72,   70,
-
-       69,   55,   53,   33,   30,    4,    3,    2,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
-      578,  578,  578,  578,  578,  578,  578
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    5,
+        6,    7,    8,    5,    6,   11,   73,   25,    7,    8,
+       23,   24,   26,   11,   12,   11,   73,  609,   23,   24,
+        9,    9,   12,    9,   12,   82,    5,    6,    7,    8,
+        9,  608,   82,    9,   25,   10,   10,    9,   10,   26,
+
+       27,   10,   19,   29,   27,   10,   19,    9,   10,   19,
+       29,   11,   10,  240,   19,    5,    6,    7,    8,   13,
+       12,  240,   10,   13,   49,   13,   13,   27,   14,   45,
+       29,   13,   14,   45,   14,   14,   49,   15,   68,  127,
+       14,   15,   68,   15,   15,  607,   16,   20,  127,   15,
+       16,   20,   16,   16,   20,   15,   17,   28,   16,   20,
+       17,   28,   17,   17,   16,   18,  100,  606,   17,   18,
+      100,   18,   18,   88,   17,   21,  107,   18,   30,   21,
+      107,   21,   21,   18,   28,   30,  258,   21,   88,  258,
+       15,  227,   15,   21,   33,   33,   22,   33,  227,   16,
+
+       22,   16,   22,   22,   33,   30,  126,   33,   22,   17,
+      126,   17,   90,   90,   22,   90,   34,   34,   18,   34,
+       18,   83,   34,   47,   47,   47,   34,   81,   21,   34,
+       21,   81,  186,   83,  116,  117,  186,  121,  146,  146,
+      117,  121,   83,  203,  116,  117,   81,  203,  186,   22,
+      121,   22,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   40,  110,  110,   40,  110,  605,  128,  158,   40,
+      138,  138,  138,  191,  113,  113,  128,  113,  158,   40,
+       40,   40,   40,   40,  191,  128,  604,   40,   40,   40,
+       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
+       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
+       40,   40,   44,  220,  220,   44,  110,   44,  123,   44,
+       46,   46,   46,  195,   44,   44,   93,   93,  113,   93,
+       44,  123,   46,  125,  199,   44,  123,  163,  163,  195,
+      163,   44,   44,  165,  165,  603,  165,  168,  168,  125,
+
+      168,  261,  125,  199,   93,  236,  170,  170,   46,  170,
+      171,  171,  231,  171,  174,  174,  199,  174,  261,  602,
+       44,   51,  176,  176,   51,  176,   51,  231,   51,  256,
+      179,  179,  236,  179,  182,  182,  256,  182,  225,   51,
+      224,  224,  225,  224,   51,  226,  226,  229,  226,  257,
+       51,   51,  228,  228,  601,  228,  257,  225,  298,  229,
+      230,  230,  311,  230,  232,  232,  332,  232,  229,  233,
+      233,  497,  233,  234,  234,  497,  234,  298,  582,   51,
+       61,  311,  335,   61,  179,  332,  362,  581,  182,   61,
+       61,  235,  235,  374,  235,  580,  579,   61,  578,  575,
+
+       61,  335,  403,   61,  510,  362,   61,   61,  365,  365,
+      365,   61,  374,  574,  391,  391,  391,  391,   61,  573,
+      572,  403,   61,  510,   61,   61,   61,   61,  133,  511,
+      402,  133,  402,  133,  391,  133,  426,  426,  426,  426,
+      133,  133,  571,  402,  402,  402,  133,  570,  511,  543,
+      544,  133,  523,  523,  523,  523,  426,  133,  133,  527,
+      527,  527,  527,  528,  528,  528,  528,  569,  543,  544,
+      566,  565,  523,  541,  541,  541,  541,  564,  563,  527,
+      562,  560,  559,  528,  558,  557,  133,  139,  139,  139,
+      556,  555,  554,  541,  553,  550,  139,  546,  546,  546,
+
+      546,  549,  548,  545,  139,  139,  139,  139,  139,  139,
+      540,  539,  531,  530,  529,  526,  525,  546,  585,  585,
+      585,  585,  585,  585,  585,  585,  585,  585,  585,  586,
+      586,  586,  586,  586,  586,  586,  586,  586,  586,  586,
+      587,  587,  587,  587,  587,  587,  587,  587,  587,  587,
+      587,  588,  588,  588,  588,  588,  588,  588,  588,  588,
+      588,  588,  589,  589,  589,  589,  589,  589,  589,  589,
+      589,  589,  589,  590,  524,  522,  521,  590,  590,  520,
+      519,  518,  517,  590,  591,  516,  515,  513,  591,  591,
+      591,  512,  591,  509,  591,  592,  592,  508,  592,  593,
+
+      593,  593,  593,  593,  593,  593,  593,  593,  593,  593,
+      594,  594,  594,  594,  594,  594,  594,  507,  594,  594,
+      594,  595,  595,  595,  595,  595,  595,  595,  595,  595,
+      596,  505,  504,  596,  596,  503,  502,  596,  501,  596,
+      597,  597,  597,  499,  597,  598,  598,  598,  498,  598,
+      599,  599,  496,  599,  599,  599,  599,  599,  599,  599,
+      599,  600,  600,  600,  495,  600,  610,  610,  494,  610,
+      610,  610,  610,  610,  610,  610,  610,  493,  492,  491,
+      490,  489,  488,  487,  486,  485,  482,  481,  480,  479,
+      478,  475,  474,  473,  472,  471,  470,  469,  468,  466,
+
+      465,  464,  463,  462,  459,  457,  456,  455,  454,  453,
+      451,  450,  449,  448,  447,  446,  445,  444,  443,  442,
+      441,  440,  439,  436,  435,  434,  432,  431,  429,  428,
+      425,  424,  423,  422,  421,  420,  419,  418,  417,  416,
+      415,  414,  413,  412,  411,  410,  409,  408,  407,  406,
+      405,  401,  400,  399,  398,  397,  396,  395,  394,  393,
+      392,  390,  389,  388,  387,  386,  385,  384,  383,  382,
+      381,  380,  379,  378,  377,  376,  375,  373,  372,  371,
+      370,  369,  364,  360,  358,  357,  356,  355,  354,  353,
+      351,  349,  348,  347,  346,  345,  344,  343,  342,  340,
+
+      339,  338,  337,  336,  334,  333,  329,  328,  327,  325,
+      322,  320,  319,  317,  315,  314,  313,  312,  310,  309,
+      308,  307,  306,  305,  304,  303,  302,  301,  300,  299,
+      297,  296,  295,  293,  292,  291,  290,  289,  288,  287,
+      286,  285,  284,  283,  282,  281,  279,  275,  274,  273,
+      272,  271,  270,  269,  268,  267,  266,  265,  264,  263,
+      262,  260,  259,  255,  254,  253,  252,  251,  250,  249,
+      248,  247,  246,  245,  244,  243,  242,  241,  239,  238,
+      237,  219,  214,  213,  212,  211,  210,  209,  208,  207,
+      206,  205,  204,  202,  201,  200,  198,  197,  196,  194,
+
+      193,  192,  190,  189,  188,  187,  185,  184,  175,  172,
+      159,  157,  142,  140,  131,  130,  129,  124,  122,  120,
+      119,  118,  115,  114,  108,  103,   79,   76,   74,   72,
+       71,   57,   55,   35,   32,    4,    3,    2,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584,  584,  584,
+      584,  584,  584,  584,  584,  584,  584,  584
+
     } ;
 
 static yy_state_type yy_last_accepting_state;
@@ -973,7 +985,7 @@
 extern int gram__flex_debug;
 int gram__flex_debug = 1;
 
-static yyconst flex_int16_t yy_rule_linenum[130] =
+static yyconst flex_int16_t yy_rule_linenum[132] =
     {   0,
       185,  188,  189,  190,  198,  216,  217,  218,  219,  220,
       221,  222,  223,  224,  225,  226,  227,  228,  229,  230,
@@ -982,13 +994,14 @@
       251,  252,  253,  254,  255,  256,  257,  258,  259,  260,
       263,  264,  265,  266,  267,  268,  269,  270,  271,  272,
       273,  275,  279,  280,  281,  283,  290,  294,  301,  306,
-      309,  312,  315,  323,  330,  331,  332,  338,  345,  352,
-      372,  382,  397,  402,  421,  434,  450,  465,  482,  483,
-      494,  505,  506,  518,  526,  536,  555,  567,  581,  582,
-
-      593,  602,  612,  613,  614,  615,  616,  617,  618,  621,
-      623,  631,  649,  654,  655,  661,  662,  673,  679,  685,
-      691,  707,  708,  712,  719,  736,  757,  790,  791
+      309,  312,  315,  323,  330,  337,  338,  339,  345,  352,
+      359,  379,  389,  404,  409,  428,  441,  457,  472,  489,
+      490,  501,  512,  513,  525,  533,  543,  562,  574,  588,
+
+      589,  600,  609,  619,  620,  621,  622,  623,  624,  625,
+      628,  630,  638,  656,  661,  662,  668,  669,  680,  686,
+      692,  698,  714,  715,  719,  726,  743,  761,  782,  815,
+      816
     } ;
 
 /* The intent behind this definition is that it'll catch
@@ -999,7 +1012,7 @@
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
 char *gram_text;
-#line 1 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 1 "src/scan-gram.l"
 /* Bison Grammar Scanner                             -*- C -*-
 
    Copyright (C) 2002-2015 Free Software Foundation, Inc.
@@ -1019,7 +1032,7 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #define YY_NO_INPUT 1
-#line 24 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 24 "src/scan-gram.l"
 /* Work around a bug in flex 2.5.31.  See Debian bug 333231
    <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=333231>.  */
 #undef gram_wrap
@@ -1129,7 +1142,7 @@
    white space between the backslash and the newline.  */
 /* An equal sign, with optional leading whitespaces. This is used in some
    deprecated constructs. */
-#line 1133 "src/scan-gram.c"
+#line 1146 "src/scan-gram.c"
 
 #define INITIAL 0
 #define SC_YACC_COMMENT 1
@@ -1139,14 +1152,15 @@
 #define SC_TAG 5
 #define SC_PROLOGUE 6
 #define SC_BRACED_CODE 7
-#define SC_EPILOGUE 8
-#define SC_PREDICATE 9
-#define SC_COMMENT 10
-#define SC_LINE_COMMENT 11
-#define SC_STRING 12
-#define SC_CHARACTER 13
-#define SC_BRACKETED_ID 14
-#define SC_RETURN_BRACKETED_ID 15
+#define SC_BRACED_PLAIN_CODE 8
+#define SC_EPILOGUE 9
+#define SC_PREDICATE 10
+#define SC_COMMENT 11
+#define SC_LINE_COMMENT 12
+#define SC_STRING 13
+#define SC_CHARACTER 14
+#define SC_BRACKETED_ID 15
+#define SC_RETURN_BRACKETED_ID 16
 
 #ifndef YY_NO_UNISTD_H
 /* Special case for "unistd.h", since it is non-ANSI. We include it way
@@ -1388,8 +1402,43 @@
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
     
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! gram_in )
+/* %if-c-only */
+			gram_in = stdin;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! gram_out )
+/* %if-c-only */
+			gram_out = stdout;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			gram_ensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				gram__create_buffer(gram_in,YY_BUF_SIZE );
+		}
+
+		gram__load_buffer_state( );
+		}
+
+	{
 /* %% [7.0] user's declarations go here */
-#line 146 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 146 "src/scan-gram.l"
 
 
   /* Nesting level.  Either for nested braces, or nested angle brackets
@@ -1426,41 +1475,7 @@
   | Scanning white space.  |
   `-----------------------*/
 
-#line 1430 "src/scan-gram.c"
-
-	if ( !(yy_init) )
-		{
-		(yy_init) = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! gram_in )
-/* %if-c-only */
-			gram_in = stdin;
-/* %endif */
-/* %if-c++-only */
-/* %endif */
-
-		if ( ! gram_out )
-/* %if-c-only */
-			gram_out = stdout;
-/* %endif */
-/* %if-c++-only */
-/* %endif */
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			gram_ensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				gram__create_buffer(gram_in,YY_BUF_SIZE );
-		}
-
-		gram__load_buffer_state( );
-		}
+#line 1479 "src/scan-gram.c"
 
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
@@ -1481,7 +1496,7 @@
 yy_match:
 		do
 			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
 			if ( yy_accept[yy_current_state] )
 				{
 				(yy_last_accepting_state) = yy_current_state;
@@ -1490,13 +1505,13 @@
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 579 )
+				if ( yy_current_state >= 585 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_current_state != 578 );
+		while ( yy_current_state != 584 );
 		yy_cp = (yy_last_accepting_cpos);
 		yy_current_state = (yy_last_accepting_state);
 
@@ -1515,13 +1530,13 @@
 			{
 			if ( yy_act == 0 )
 				fprintf( stderr, "--scanner backing up\n" );
-			else if ( yy_act < 130 )
+			else if ( yy_act < 132 )
 				fprintf( stderr, "--accepting rule at line %ld (\"%s\")\n",
 				         (long)yy_rule_linenum[yy_act], gram_text );
-			else if ( yy_act == 130 )
+			else if ( yy_act == 132 )
 				fprintf( stderr, "--accepting default rule (\"%s\")\n",
 				         gram_text );
-			else if ( yy_act == 131 )
+			else if ( yy_act == 133 )
 				fprintf( stderr, "--(end of buffer or a NUL)\n" );
 			else
 				fprintf( stderr, "--EOF (start condition %d)\n", YY_START );
@@ -1540,23 +1555,23 @@
 /* Comments and white space.  */
 case 1:
 YY_RULE_SETUP
-#line 185 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 185 "src/scan-gram.l"
 {
      complain (loc, Wother, _("stray ',' treated as white space"));
   }
 	YY_BREAK
 case 2:
 /* rule 2 can match eol */
-#line 189 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 189 "src/scan-gram.l"
 case 3:
 /* rule 3 can match eol */
 YY_RULE_SETUP
-#line 189 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 189 "src/scan-gram.l"
 continue;
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 190 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 190 "src/scan-gram.l"
 {
     token_start = loc->start;
     context_state = YY_START;
@@ -1568,7 +1583,7 @@
 case 5:
 /* rule 5 can match eol */
 YY_RULE_SETUP
-#line 198 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 198 "src/scan-gram.l"
 {
     handle_syncline (gram_text + sizeof "#line " - 1, *loc);
   }
@@ -1586,313 +1601,313 @@
 
 case 6:
 YY_RULE_SETUP
-#line 216 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 216 "src/scan-gram.l"
 return PERCENT_NONASSOC;
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 217 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 217 "src/scan-gram.l"
 return PERCENT_CODE;
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 218 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 218 "src/scan-gram.l"
 RETURN_PERCENT_FLAG("parse.trace");
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 219 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 219 "src/scan-gram.l"
 return PERCENT_DEFAULT_PREC;
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 220 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 220 "src/scan-gram.l"
 return PERCENT_DEFINE;
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 221 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 221 "src/scan-gram.l"
 return PERCENT_DEFINES;
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 222 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 222 "src/scan-gram.l"
 return PERCENT_DESTRUCTOR;
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 223 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 223 "src/scan-gram.l"
 return PERCENT_DPREC;
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 224 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 224 "src/scan-gram.l"
 return PERCENT_EMPTY;
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 225 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 225 "src/scan-gram.l"
 return PERCENT_ERROR_VERBOSE;
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 226 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 226 "src/scan-gram.l"
 return PERCENT_EXPECT;
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 227 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 227 "src/scan-gram.l"
 return PERCENT_EXPECT_RR;
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 228 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 228 "src/scan-gram.l"
 return PERCENT_FILE_PREFIX;
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 229 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 229 "src/scan-gram.l"
 return PERCENT_YACC;
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 230 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 230 "src/scan-gram.l"
 return PERCENT_INITIAL_ACTION;
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 231 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 231 "src/scan-gram.l"
 return PERCENT_GLR_PARSER;
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 232 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 232 "src/scan-gram.l"
 return PERCENT_LANGUAGE;
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 233 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 233 "src/scan-gram.l"
 return PERCENT_LEFT;
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 234 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 234 "src/scan-gram.l"
 RETURN_PERCENT_PARAM(lex);
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 235 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 235 "src/scan-gram.l"
 RETURN_PERCENT_FLAG("locations");
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 236 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 236 "src/scan-gram.l"
 return PERCENT_MERGE;
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 237 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 237 "src/scan-gram.l"
 return PERCENT_NAME_PREFIX;
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 238 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 238 "src/scan-gram.l"
 return PERCENT_NO_DEFAULT_PREC;
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 239 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 239 "src/scan-gram.l"
 return PERCENT_NO_LINES;
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 240 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 240 "src/scan-gram.l"
 return PERCENT_NONASSOC;
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 241 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 241 "src/scan-gram.l"
 return PERCENT_NONDETERMINISTIC_PARSER;
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 242 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 242 "src/scan-gram.l"
 return PERCENT_NTERM;
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 243 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 243 "src/scan-gram.l"
 return PERCENT_OUTPUT;
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 244 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 244 "src/scan-gram.l"
 RETURN_PERCENT_PARAM(both);
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 245 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 245 "src/scan-gram.l"
 RETURN_PERCENT_PARAM(parse);
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 246 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 246 "src/scan-gram.l"
 return PERCENT_PREC;
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 247 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 247 "src/scan-gram.l"
 return PERCENT_PRECEDENCE;
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 248 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 248 "src/scan-gram.l"
 return PERCENT_PRINTER;
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 249 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 249 "src/scan-gram.l"
 RETURN_PERCENT_FLAG("api.pure");
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 250 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 250 "src/scan-gram.l"
 return PERCENT_REQUIRE;
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 251 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 251 "src/scan-gram.l"
 return PERCENT_RIGHT;
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 252 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 252 "src/scan-gram.l"
 return PERCENT_SKELETON;
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 253 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 253 "src/scan-gram.l"
 return PERCENT_START;
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 254 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 254 "src/scan-gram.l"
 return PERCENT_TOKEN;
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 255 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 255 "src/scan-gram.l"
 return PERCENT_TOKEN;
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 256 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 256 "src/scan-gram.l"
 return PERCENT_TOKEN_TABLE;
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 257 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 257 "src/scan-gram.l"
 return PERCENT_TYPE;
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 258 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 258 "src/scan-gram.l"
 return PERCENT_UNION;
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 259 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 259 "src/scan-gram.l"
 return PERCENT_VERBOSE;
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 260 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 260 "src/scan-gram.l"
 return PERCENT_YACC;
 	YY_BREAK
 /* deprecated */
 case 51:
 YY_RULE_SETUP
-#line 263 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 263 "src/scan-gram.l"
 DEPRECATED("%default-prec");
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 264 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 264 "src/scan-gram.l"
 DEPRECATED("%define parse.error verbose");
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 265 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 265 "src/scan-gram.l"
 DEPRECATED("%expect-rr");
 	YY_BREAK
 case 54:
 /* rule 54 can match eol */
 YY_RULE_SETUP
-#line 266 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 266 "src/scan-gram.l"
 DEPRECATED("%file-prefix");
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 267 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 267 "src/scan-gram.l"
 DEPRECATED("%fixed-output-files");
 	YY_BREAK
 case 56:
 /* rule 56 can match eol */
 YY_RULE_SETUP
-#line 268 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 268 "src/scan-gram.l"
 DEPRECATED("%name-prefix");
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 269 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 269 "src/scan-gram.l"
 DEPRECATED("%no-default-prec");
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 270 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 270 "src/scan-gram.l"
 DEPRECATED("%no-lines");
 	YY_BREAK
 case 59:
 /* rule 59 can match eol */
 YY_RULE_SETUP
-#line 271 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 271 "src/scan-gram.l"
 DEPRECATED("%output");
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 272 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 272 "src/scan-gram.l"
 DEPRECATED("%pure-parser");
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 273 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 273 "src/scan-gram.l"
 DEPRECATED("%token-table");
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 275 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 275 "src/scan-gram.l"
 {
     complain (loc, complaint, _("invalid directive: %s"), quote (gram_text));
   }
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 279 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 279 "src/scan-gram.l"
 return EQUAL;
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 280 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 280 "src/scan-gram.l"
 return PIPE;
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 281 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 281 "src/scan-gram.l"
 return SEMICOLON;
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 283 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 283 "src/scan-gram.l"
 {
     val->uniqstr = uniqstr_new (gram_text);
     id_loc = *loc;
@@ -1902,7 +1917,7 @@
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 290 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 290 "src/scan-gram.l"
 {
     val->integer = scan_integer (gram_text, 10, *loc);
     return INT;
@@ -1910,7 +1925,7 @@
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 294 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 294 "src/scan-gram.l"
 {
     val->integer = scan_integer (gram_text, 16, *loc);
     return INT;
@@ -1920,7 +1935,7 @@
      accept "1FOO" as "1 FOO".  */
 case 69:
 YY_RULE_SETUP
-#line 301 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 301 "src/scan-gram.l"
 {
     complain (loc, complaint, _("invalid identifier: %s"), quote (gram_text));
   }
@@ -1928,25 +1943,25 @@
 /* Characters.  */
 case 70:
 YY_RULE_SETUP
-#line 306 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 306 "src/scan-gram.l"
 token_start = loc->start; BEGIN SC_ESCAPED_CHARACTER;
 	YY_BREAK
 /* Strings. */
 case 71:
 YY_RULE_SETUP
-#line 309 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 309 "src/scan-gram.l"
 token_start = loc->start; BEGIN SC_ESCAPED_STRING;
 	YY_BREAK
 /* Prologue. */
 case 72:
 YY_RULE_SETUP
-#line 312 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 312 "src/scan-gram.l"
 code_start = loc->start; BEGIN SC_PROLOGUE;
 	YY_BREAK
 /* Code in between braces.  */
 case 73:
 YY_RULE_SETUP
-#line 315 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 315 "src/scan-gram.l"
 {
     STRING_GROW;
     nesting = 0;
@@ -1954,11 +1969,22 @@
     BEGIN SC_BRACED_CODE;
   }
 	YY_BREAK
-/* Semantic predicate. */
+/* Plain code. */
 case 74:
 /* rule 74 can match eol */
 YY_RULE_SETUP
-#line 323 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 323 "src/scan-gram.l"
+{
+    nesting = 0;
+    code_start = loc->start;
+    BEGIN SC_BRACED_PLAIN_CODE;
+  }
+	YY_BREAK
+/* Semantic predicate. */
+case 75:
+/* rule 75 can match eol */
+YY_RULE_SETUP
+#line 330 "src/scan-gram.l"
 {
     nesting = 0;
     code_start = loc->start;
@@ -1966,28 +1992,28 @@
   }
 	YY_BREAK
 /* A type. */
-case 75:
+case 76:
 YY_RULE_SETUP
-#line 330 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 337 "src/scan-gram.l"
 return TAG_ANY;
 	YY_BREAK
-case 76:
+case 77:
 YY_RULE_SETUP
-#line 331 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 338 "src/scan-gram.l"
 return TAG_NONE;
 	YY_BREAK
-case 77:
+case 78:
 YY_RULE_SETUP
-#line 332 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 339 "src/scan-gram.l"
 {
     nesting = 0;
     token_start = loc->start;
     BEGIN SC_TAG;
   }
 	YY_BREAK
-case 78:
+case 79:
 YY_RULE_SETUP
-#line 338 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 345 "src/scan-gram.l"
 {
     static int percent_percent_count;
     if (++percent_percent_count == 2)
@@ -1995,9 +2021,9 @@
     return PERCENT_PERCENT;
   }
 	YY_BREAK
-case 79:
+case 80:
 YY_RULE_SETUP
-#line 345 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 352 "src/scan-gram.l"
 {
     bracketed_id_str = NULL;
     bracketed_id_start = loc->start;
@@ -2005,9 +2031,9 @@
     BEGIN SC_BRACKETED_ID;
   }
 	YY_BREAK
-case 80:
+case 81:
 YY_RULE_SETUP
-#line 352 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 359 "src/scan-gram.l"
 {
     complain (loc, complaint, "%s: %s",
               ngettext ("invalid character", "invalid characters", gram_leng),
@@ -2015,7 +2041,7 @@
   }
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
-#line 358 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 365 "src/scan-gram.l"
 {
     loc->start = loc->end = scanner_cursor;
     yyterminate ();
@@ -2028,9 +2054,9 @@
   `--------------------------------------------------------------*/
 
 
-case 81:
+case 82:
 YY_RULE_SETUP
-#line 372 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 379 "src/scan-gram.l"
 complain (loc, complaint, _("invalid null character"));
 	YY_BREAK
 
@@ -2039,9 +2065,9 @@
   `-----------------------------------------------------------------*/
 
 
-case 82:
+case 83:
 YY_RULE_SETUP
-#line 382 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 389 "src/scan-gram.l"
 {
     if (bracketed_id_str)
       {
@@ -2058,18 +2084,18 @@
       }
   }
 	YY_BREAK
-case 83:
+case 84:
 YY_RULE_SETUP
-#line 397 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 404 "src/scan-gram.l"
 {
     BEGIN (bracketed_id_str ? SC_RETURN_BRACKETED_ID : INITIAL);
     *loc = id_loc;
     return ID_COLON;
   }
 	YY_BREAK
-case 84:
+case 85:
 YY_RULE_SETUP
-#line 402 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 409 "src/scan-gram.l"
 {
     ROLLBACK_CURRENT_TOKEN;
     BEGIN (bracketed_id_str ? SC_RETURN_BRACKETED_ID : INITIAL);
@@ -2078,7 +2104,7 @@
   }
 	YY_BREAK
 case YY_STATE_EOF(SC_AFTER_IDENTIFIER):
-#line 408 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 415 "src/scan-gram.l"
 {
     BEGIN (bracketed_id_str ? SC_RETURN_BRACKETED_ID : INITIAL);
     *loc = id_loc;
@@ -2091,9 +2117,9 @@
   `--------------------------------*/
 
 
-case 85:
+case 86:
 YY_RULE_SETUP
-#line 421 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 428 "src/scan-gram.l"
 {
     if (bracketed_id_str)
       {
@@ -2108,9 +2134,9 @@
       }
   }
 	YY_BREAK
-case 86:
+case 87:
 YY_RULE_SETUP
-#line 434 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 441 "src/scan-gram.l"
 {
     BEGIN bracketed_id_context_state;
     if (bracketed_id_str)
@@ -2127,9 +2153,9 @@
       complain (loc, complaint, _("an identifier expected"));
   }
 	YY_BREAK
-case 87:
+case 88:
 YY_RULE_SETUP
-#line 450 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 457 "src/scan-gram.l"
 {
     complain (loc, complaint, "%s: %s",
               ngettext ("invalid character in bracketed name",
@@ -2138,7 +2164,7 @@
   }
 	YY_BREAK
 case YY_STATE_EOF(SC_BRACKETED_ID):
-#line 457 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 464 "src/scan-gram.l"
 {
     BEGIN bracketed_id_context_state;
     unexpected_eof (bracketed_id_start, "]");
@@ -2147,9 +2173,9 @@
 
 
 
-case 88:
+case 89:
 YY_RULE_SETUP
-#line 465 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 472 "src/scan-gram.l"
 {
     ROLLBACK_CURRENT_TOKEN;
     val->uniqstr = bracketed_id_str;
@@ -2165,19 +2191,19 @@
   `---------------------------------------------------------------*/
 
 
-case 89:
+case 90:
 YY_RULE_SETUP
-#line 482 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 489 "src/scan-gram.l"
 BEGIN context_state;
 	YY_BREAK
-case 90:
-/* rule 90 can match eol */
+case 91:
+/* rule 91 can match eol */
 YY_RULE_SETUP
-#line 483 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 490 "src/scan-gram.l"
 continue;
 	YY_BREAK
 case YY_STATE_EOF(SC_YACC_COMMENT):
-#line 484 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 491 "src/scan-gram.l"
 unexpected_eof (token_start, "*/"); BEGIN context_state;
 	YY_BREAK
 
@@ -2186,14 +2212,14 @@
   `------------------------------------------------------------*/
 
 
-case 91:
-/* rule 91 can match eol */
+case 92:
+/* rule 92 can match eol */
 YY_RULE_SETUP
-#line 494 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 501 "src/scan-gram.l"
 STRING_GROW; BEGIN context_state;
 	YY_BREAK
 case YY_STATE_EOF(SC_COMMENT):
-#line 495 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 502 "src/scan-gram.l"
 unexpected_eof (token_start, "*/"); BEGIN context_state;
 	YY_BREAK
 
@@ -2202,20 +2228,20 @@
   `--------------------------------------------------------------*/
 
 
-case 92:
-/* rule 92 can match eol */
+case 93:
+/* rule 93 can match eol */
 YY_RULE_SETUP
-#line 505 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 512 "src/scan-gram.l"
 STRING_GROW; BEGIN context_state;
 	YY_BREAK
-case 93:
-/* rule 93 can match eol */
+case 94:
+/* rule 94 can match eol */
 YY_RULE_SETUP
-#line 506 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 513 "src/scan-gram.l"
 STRING_GROW;
 	YY_BREAK
 case YY_STATE_EOF(SC_LINE_COMMENT):
-#line 507 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 514 "src/scan-gram.l"
 BEGIN context_state;
 	YY_BREAK
 
@@ -2225,9 +2251,9 @@
   `------------------------------------------------*/
 
 
-case 94:
+case 95:
 YY_RULE_SETUP
-#line 518 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 525 "src/scan-gram.l"
 {
     STRING_FINISH;
     loc->start = token_start;
@@ -2237,13 +2263,13 @@
   }
 	YY_BREAK
 case YY_STATE_EOF(SC_ESCAPED_STRING):
-#line 525 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 532 "src/scan-gram.l"
 unexpected_eof (token_start, "\"");
 	YY_BREAK
-case 95:
-/* rule 95 can match eol */
+case 96:
+/* rule 96 can match eol */
 YY_RULE_SETUP
-#line 526 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 533 "src/scan-gram.l"
 unexpected_newline (token_start, "\"");
 	YY_BREAK
 
@@ -2253,9 +2279,9 @@
   `----------------------------------------------------------*/
 
 
-case 96:
+case 97:
 YY_RULE_SETUP
-#line 536 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 543 "src/scan-gram.l"
 {
     STRING_FINISH;
     loc->start = token_start;
@@ -2276,14 +2302,14 @@
     return CHAR;
   }
 	YY_BREAK
-case 97:
-/* rule 97 can match eol */
+case 98:
+/* rule 98 can match eol */
 YY_RULE_SETUP
-#line 555 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 562 "src/scan-gram.l"
 unexpected_newline (token_start, "'");
 	YY_BREAK
 case YY_STATE_EOF(SC_ESCAPED_CHARACTER):
-#line 556 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 563 "src/scan-gram.l"
 unexpected_eof (token_start, "'");
 	YY_BREAK
 
@@ -2292,9 +2318,9 @@
   `--------------------------------------------------------------*/
 
 
-case 98:
+case 99:
 YY_RULE_SETUP
-#line 567 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 574 "src/scan-gram.l"
 {
     --nesting;
     if (nesting < 0)
@@ -2309,19 +2335,19 @@
     STRING_GROW;
   }
 	YY_BREAK
-case 99:
-/* rule 99 can match eol */
+case 100:
+/* rule 100 can match eol */
 YY_RULE_SETUP
-#line 581 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 588 "src/scan-gram.l"
 STRING_GROW;
 	YY_BREAK
-case 100:
+case 101:
 YY_RULE_SETUP
-#line 582 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 589 "src/scan-gram.l"
 STRING_GROW; nesting += gram_leng;
 	YY_BREAK
 case YY_STATE_EOF(SC_TAG):
-#line 584 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 591 "src/scan-gram.l"
 unexpected_eof (token_start, ">");
 	YY_BREAK
 
@@ -2330,9 +2356,9 @@
   `----------------------------*/
 
 
-case 101:
+case 102:
 YY_RULE_SETUP
-#line 593 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 600 "src/scan-gram.l"
 {
     unsigned long int c = strtoul (gram_text + 1, NULL, 8);
     if (!c || UCHAR_MAX < c)
@@ -2342,9 +2368,9 @@
       obstack_1grow (&obstack_for_string, c);
   }
 	YY_BREAK
-case 102:
+case 103:
 YY_RULE_SETUP
-#line 602 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 609 "src/scan-gram.l"
 {
     verify (UCHAR_MAX < ULONG_MAX);
     unsigned long int c = strtoul (gram_text + 2, NULL, 16);
@@ -2355,50 +2381,50 @@
       obstack_1grow (&obstack_for_string, c);
   }
 	YY_BREAK
-case 103:
+case 104:
 YY_RULE_SETUP
-#line 612 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 619 "src/scan-gram.l"
 obstack_1grow (&obstack_for_string, '\a');
 	YY_BREAK
-case 104:
+case 105:
 YY_RULE_SETUP
-#line 613 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 620 "src/scan-gram.l"
 obstack_1grow (&obstack_for_string, '\b');
 	YY_BREAK
-case 105:
+case 106:
 YY_RULE_SETUP
-#line 614 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 621 "src/scan-gram.l"
 obstack_1grow (&obstack_for_string, '\f');
 	YY_BREAK
-case 106:
+case 107:
 YY_RULE_SETUP
-#line 615 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 622 "src/scan-gram.l"
 obstack_1grow (&obstack_for_string, '\n');
 	YY_BREAK
-case 107:
+case 108:
 YY_RULE_SETUP
-#line 616 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 623 "src/scan-gram.l"
 obstack_1grow (&obstack_for_string, '\r');
 	YY_BREAK
-case 108:
+case 109:
 YY_RULE_SETUP
-#line 617 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 624 "src/scan-gram.l"
 obstack_1grow (&obstack_for_string, '\t');
 	YY_BREAK
-case 109:
+case 110:
 YY_RULE_SETUP
-#line 618 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 625 "src/scan-gram.l"
 obstack_1grow (&obstack_for_string, '\v');
 	YY_BREAK
 /* \\[\"\'?\\] would be shorter, but it confuses xgettext.  */
-case 110:
+case 111:
 YY_RULE_SETUP
-#line 621 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 628 "src/scan-gram.l"
 obstack_1grow (&obstack_for_string, gram_text[1]);
 	YY_BREAK
-case 111:
+case 112:
 YY_RULE_SETUP
-#line 623 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 630 "src/scan-gram.l"
 {
     int c = convert_ucn_to_byte (gram_text);
     if (c <= 0)
@@ -2408,10 +2434,10 @@
       obstack_1grow (&obstack_for_string, c);
   }
 	YY_BREAK
-case 112:
-/* rule 112 can match eol */
+case 113:
+/* rule 113 can match eol */
 YY_RULE_SETUP
-#line 631 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 638 "src/scan-gram.l"
 {
     char const *p = gram_text + 1;
     /* Quote only if escaping won't make the character visible.  */
@@ -2429,46 +2455,46 @@
   `--------------------------------------------*/
 
 
-case 113:
-/* rule 113 can match eol */
+case 114:
+/* rule 114 can match eol */
 YY_RULE_SETUP
-#line 649 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 656 "src/scan-gram.l"
 STRING_GROW;
 	YY_BREAK
 
 
 
-case 114:
+case 115:
 YY_RULE_SETUP
-#line 654 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 661 "src/scan-gram.l"
 STRING_GROW; BEGIN context_state;
 	YY_BREAK
-case 115:
-/* rule 115 can match eol */
+case 116:
+/* rule 116 can match eol */
 YY_RULE_SETUP
-#line 655 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 662 "src/scan-gram.l"
 unexpected_newline (token_start, "'");
 	YY_BREAK
 case YY_STATE_EOF(SC_CHARACTER):
-#line 656 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 663 "src/scan-gram.l"
 unexpected_eof (token_start, "'");
 	YY_BREAK
 
 
 
-case 116:
+case 117:
 YY_RULE_SETUP
-#line 661 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 668 "src/scan-gram.l"
 STRING_GROW; BEGIN context_state;
 	YY_BREAK
-case 117:
-/* rule 117 can match eol */
+case 118:
+/* rule 118 can match eol */
 YY_RULE_SETUP
-#line 662 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 669 "src/scan-gram.l"
 unexpected_newline (token_start, "\"");
 	YY_BREAK
 case YY_STATE_EOF(SC_STRING):
-#line 663 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 670 "src/scan-gram.l"
 unexpected_eof (token_start, "\"");
 	YY_BREAK
 
@@ -2477,9 +2503,9 @@
   `---------------------------------------------------*/
 
 
-case 118:
+case 119:
 YY_RULE_SETUP
-#line 673 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 680 "src/scan-gram.l"
 {
     STRING_GROW;
     context_state = YY_START;
@@ -2487,9 +2513,9 @@
     BEGIN SC_CHARACTER;
   }
 	YY_BREAK
-case 119:
+case 120:
 YY_RULE_SETUP
-#line 679 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 686 "src/scan-gram.l"
 {
     STRING_GROW;
     context_state = YY_START;
@@ -2497,10 +2523,10 @@
     BEGIN SC_STRING;
   }
 	YY_BREAK
-case 120:
-/* rule 120 can match eol */
+case 121:
+/* rule 121 can match eol */
 YY_RULE_SETUP
-#line 685 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 692 "src/scan-gram.l"
 {
     STRING_GROW;
     context_state = YY_START;
@@ -2508,10 +2534,10 @@
     BEGIN SC_COMMENT;
   }
 	YY_BREAK
-case 121:
-/* rule 121 can match eol */
+case 122:
+/* rule 122 can match eol */
 YY_RULE_SETUP
-#line 691 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 698 "src/scan-gram.l"
 {
     STRING_GROW;
     context_state = YY_START;
@@ -2525,37 +2551,38 @@
   `-----------------------------------------------------------*/
 
 
-case 122:
-/* rule 122 can match eol */
+case 123:
+/* rule 123 can match eol */
 YY_RULE_SETUP
-#line 707 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 714 "src/scan-gram.l"
 STRING_GROW; nesting++;
 	YY_BREAK
-case 123:
-/* rule 123 can match eol */
+case 124:
+/* rule 124 can match eol */
 YY_RULE_SETUP
-#line 708 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 715 "src/scan-gram.l"
 STRING_GROW; nesting--;
 	YY_BREAK
 /* Tokenize '<<%' correctly (as '<<' '%') rather than incorrrectly
      (as '<' '<%').  */
-case 124:
-/* rule 124 can match eol */
+case 125:
+/* rule 125 can match eol */
 YY_RULE_SETUP
-#line 712 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 719 "src/scan-gram.l"
 STRING_GROW;
 	YY_BREAK
 case YY_STATE_EOF(SC_BRACED_CODE):
+case YY_STATE_EOF(SC_BRACED_PLAIN_CODE):
 case YY_STATE_EOF(SC_PREDICATE):
-#line 714 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 721 "src/scan-gram.l"
 unexpected_eof (code_start, "}");
 	YY_BREAK
 
 
 
-case 125:
+case 126:
 YY_RULE_SETUP
-#line 719 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 726 "src/scan-gram.l"
 {
     obstack_1grow (&obstack_for_string, '}');
 
@@ -2573,9 +2600,30 @@
 
 
 
-case 126:
+case 127:
+YY_RULE_SETUP
+#line 743 "src/scan-gram.l"
+{
+
+    --nesting;
+    if (nesting < 0)
+      {
+        STRING_FINISH;
+        loc->start = code_start;
+        val->code = last_string;
+        BEGIN INITIAL;
+        return BRACED_PLAIN_CODE;
+      }
+    else
+      obstack_1grow (&obstack_for_string, '}');
+  }
+	YY_BREAK
+
+
+
+case 128:
 YY_RULE_SETUP
-#line 736 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 761 "src/scan-gram.l"
 {
     --nesting;
     if (nesting < 0)
@@ -2596,9 +2644,9 @@
   `--------------------------------------------------------------*/
 
 
-case 127:
+case 129:
 YY_RULE_SETUP
-#line 757 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 782 "src/scan-gram.l"
 {
     STRING_FINISH;
     loc->start = code_start;
@@ -2608,7 +2656,7 @@
   }
 	YY_BREAK
 case YY_STATE_EOF(SC_PROLOGUE):
-#line 765 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 790 "src/scan-gram.l"
 unexpected_eof (code_start, "%}");
 	YY_BREAK
 
@@ -2619,7 +2667,7 @@
 
 
 case YY_STATE_EOF(SC_EPILOGUE):
-#line 776 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 801 "src/scan-gram.l"
 {
     STRING_FINISH;
     loc->start = code_start;
@@ -2632,20 +2680,20 @@
 /*-----------------------------------------------------.
   | By default, grow the string obstack with the input.  |
   `-----------------------------------------------------*/
-case 128:
-#line 791 "/Users/akim/src/gnu/bison/src/scan-gram.l"
-case 129:
-/* rule 129 can match eol */
+case 130:
+#line 816 "src/scan-gram.l"
+case 131:
+/* rule 131 can match eol */
 YY_RULE_SETUP
-#line 791 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 816 "src/scan-gram.l"
 STRING_GROW;
 	YY_BREAK
-case 130:
+case 132:
 YY_RULE_SETUP
-#line 793 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 818 "src/scan-gram.l"
 YY_FATAL_ERROR( "flex scanner jammed" );
 	YY_BREAK
-#line 2649 "src/scan-gram.c"
+#line 2697 "src/scan-gram.c"
 case YY_STATE_EOF(SC_RETURN_BRACKETED_ID):
 	yyterminate();
 
@@ -2778,6 +2826,7 @@
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
+	} /* end of user's declarations */
 } /* end of gram_lex */
 /* %ok-for-header */
 
@@ -2951,7 +3000,7 @@
 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
 /* %% [16.0] code to find the next state goes here */
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 58);
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 59);
 		if ( yy_accept[yy_current_state] )
 			{
 			(yy_last_accepting_state) = yy_current_state;
@@ -2960,7 +3009,7 @@
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 579 )
+			if ( yy_current_state >= 585 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
@@ -2984,7 +3033,7 @@
     /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
 	register char *yy_cp = (yy_c_buf_p);
 
-	register YY_CHAR yy_c = 58;
+	register YY_CHAR yy_c = 59;
 	if ( yy_accept[yy_current_state] )
 		{
 		(yy_last_accepting_state) = yy_current_state;
@@ -2993,11 +3042,11 @@
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 579 )
+		if ( yy_current_state >= 585 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 578);
+	yy_is_jam = (yy_current_state == 584);
 
 		return yy_is_jam ? 0 : yy_current_state;
 }
@@ -3512,7 +3561,7 @@
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
-	int i;
+	yy_size_t i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
 	n = _yybytes_len + 2;
@@ -3772,7 +3821,7 @@
 
 /* %ok-for-header */
 
-#line 793 "/Users/akim/src/gnu/bison/src/scan-gram.l"
+#line 818 "src/scan-gram.l"
 
 
 
diff -ruN bison-3.0.4/src/scan-gram.l bison-3.0.4b/src/scan-gram.l
--- bison-3.0.4/src/scan-gram.l	2015-01-16 09:47:42.000000000 -0500
+++ bison-3.0.4b/src/scan-gram.l	2015-12-23 22:00:53.222472300 -0500
@@ -122,7 +122,7 @@
     - actions, printers, union, etc, (between braced in the middle section);
     - epilogue (everything after the second %%).
     - predicate (code between '%?{' and '{' in middle section); */
-%x SC_PROLOGUE SC_BRACED_CODE SC_EPILOGUE SC_PREDICATE
+%x SC_PROLOGUE SC_BRACED_CODE SC_BRACED_PLAIN_CODE SC_EPILOGUE SC_PREDICATE
  /* C and C++ comments in code. */
 %x SC_COMMENT SC_LINE_COMMENT
  /* Strings and characters in code. */
@@ -319,6 +319,13 @@
     BEGIN SC_BRACED_CODE;
   }
 
+  /* Plain code. */
+  "%!"[ \f\n\t\v]*"{" {
+    nesting = 0;
+    code_start = loc->start;
+    BEGIN SC_BRACED_PLAIN_CODE;
+  }
+
   /* Semantic predicate. */
   "%?"[ \f\n\t\v]*"{" {
     nesting = 0;
@@ -668,7 +675,7 @@
   | Strings, comments etc. can be found in user code.  |
   `---------------------------------------------------*/
 
-<SC_BRACED_CODE,SC_PROLOGUE,SC_EPILOGUE,SC_PREDICATE>
+<SC_BRACED_CODE,SC_BRACED_PLAIN_CODE,SC_PROLOGUE,SC_EPILOGUE,SC_PREDICATE>
 {
   "'" {
     STRING_GROW;
@@ -702,7 +709,7 @@
   | initial "{" is already eaten.                              |
   `-----------------------------------------------------------*/
 
-<SC_BRACED_CODE,SC_PREDICATE>
+<SC_BRACED_CODE,SC_BRACED_PLAIN_CODE,SC_PREDICATE>
 {
   "{"|"<"{splice}"%"  STRING_GROW; nesting++;
   "%"{splice}">"      STRING_GROW; nesting--;
@@ -731,6 +738,24 @@
   }
 }
 
+<SC_BRACED_PLAIN_CODE>
+{
+  "}" {
+
+    --nesting;
+    if (nesting < 0)
+      {
+        STRING_FINISH;
+        loc->start = code_start;
+        val->code = last_string;
+        BEGIN INITIAL;
+        return BRACED_PLAIN_CODE;
+      }
+    else
+      obstack_1grow (&obstack_for_string, '}');
+  }
+}
+
 <SC_PREDICATE>
 {
   "}" {
@@ -787,8 +812,8 @@
   | By default, grow the string obstack with the input.  |
   `-----------------------------------------------------*/
 
-<SC_COMMENT,SC_LINE_COMMENT,SC_BRACED_CODE,SC_PREDICATE,SC_PROLOGUE,SC_EPILOGUE,SC_STRING,SC_CHARACTER,SC_ESCAPED_STRING,SC_ESCAPED_CHARACTER>. |
-  <SC_COMMENT,SC_LINE_COMMENT,SC_BRACED_CODE,SC_PREDICATE,SC_PROLOGUE,SC_EPILOGUE>\n    STRING_GROW;
+<SC_COMMENT,SC_LINE_COMMENT,SC_BRACED_CODE,SC_BRACED_PLAIN_CODE,SC_PREDICATE,SC_PROLOGUE,SC_EPILOGUE,SC_STRING,SC_CHARACTER,SC_ESCAPED_STRING,SC_ESCAPED_CHARACTER>. |
+  <SC_COMMENT,SC_LINE_COMMENT,SC_BRACED_CODE,SC_BRACED_PLAIN_CODE,SC_PREDICATE,SC_PROLOGUE,SC_EPILOGUE>\n    STRING_GROW;
 
 %%
 
diff -ruN bison-3.0.4/src/scan-php.c bison-3.0.4b/src/scan-php.c
--- bison-3.0.4/src/scan-php.c	1969-12-31 19:00:00.000000000 -0500
+++ bison-3.0.4b/src/scan-php.c	2016-02-05 19:48:31.884851900 -0500
@@ -0,0 +1,3014 @@
+#line 2 "src/scan-php.c"
+
+#line 4 "src/scan-php.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+/* %not-for-header */
+
+/* %if-c-only */
+/* %if-not-reentrant */
+#define yy_create_buffer php__create_buffer
+#define yy_delete_buffer php__delete_buffer
+#define yy_flex_debug php__flex_debug
+#define yy_init_buffer php__init_buffer
+#define yy_flush_buffer php__flush_buffer
+#define yy_load_buffer_state php__load_buffer_state
+#define yy_switch_to_buffer php__switch_to_buffer
+#define yyin php_in
+#define yyleng php_leng
+#define yylex php_lex
+#define yylineno php_lineno
+#define yyout php_out
+#define yyrestart php_restart
+#define yytext php_text
+#define yywrap php_wrap
+#define yyalloc php_alloc
+#define yyrealloc php_realloc
+#define yyfree php_free
+
+/* %endif */
+/* %endif */
+/* %ok-for-header */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 39
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* %if-c++-only */
+/* %endif */
+
+/* %if-c-only */
+    
+/* %endif */
+
+/* %if-c-only */
+
+/* %endif */
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+/* %if-c-only */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+/* %endif */
+
+/* %if-tables-serialization */
+/* %endif */
+/* end standard C headers. */
+
+/* %if-c-or-c++ */
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* %not-for-header */
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+/* %ok-for-header */
+
+/* %not-for-header */
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+/* %ok-for-header */
+
+/* %if-reentrant */
+/* %endif */
+
+/* %if-not-reentrant */
+
+/* %endif */
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE php_restart(php_in  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+/* %if-not-reentrant */
+extern yy_size_t php_leng;
+/* %endif */
+
+/* %if-c-only */
+/* %if-not-reentrant */
+extern FILE *php_in, *php_out;
+/* %endif */
+/* %endif */
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up php_text. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up php_text again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+/* %if-c-only */
+	FILE *yy_input_file;
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	yy_size_t yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via php_restart()), so that the user can continue scanning by
+	 * just pointing php_in at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+
+/* %if-not-reentrant */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+/* %endif */
+/* %ok-for-header */
+
+/* %endif */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* %if-c-only Standard (non-C++) definition */
+
+/* %if-not-reentrant */
+/* %not-for-header */
+
+/* yy_hold_char holds the character lost when php_text is formed. */
+static char yy_hold_char;
+static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
+yy_size_t php_leng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow php_wrap()'s to do buffer switches
+ * instead of setting up a fresh php_in.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+/* %ok-for-header */
+
+/* %endif */
+
+void php_restart (FILE *input_file  );
+void php__switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE php__create_buffer (FILE *file,int size  );
+void php__delete_buffer (YY_BUFFER_STATE b  );
+void php__flush_buffer (YY_BUFFER_STATE b  );
+void php_push_buffer_state (YY_BUFFER_STATE new_buffer  );
+void php_pop_buffer_state (void );
+
+static void php_ensure_buffer_stack (void );
+static void php__load_buffer_state (void );
+static void php__init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER php__flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE php__scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE php__scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE php__scan_bytes (yyconst char *bytes,yy_size_t len  );
+
+/* %endif */
+
+void *php_alloc (yy_size_t  );
+void *php_realloc (void *,yy_size_t  );
+void php_free (void *  );
+
+#define yy_new_buffer php__create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        php_ensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            php__create_buffer(php_in,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        php_ensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            php__create_buffer(php_in,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* %% [1.0] php_text/php_in/php_out/yy_state_type/php_lineno etc. def's & init go here */
+/* Begin user sect3 */
+
+#define php_wrap() 1
+#define YY_SKIP_YYWRAP
+
+#define FLEX_DEBUG
+
+typedef unsigned char YY_CHAR;
+
+FILE *php_in = (FILE *) 0, *php_out = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int php_lineno;
+
+int php_lineno = 1;
+
+extern char *php_text;
+#define yytext_ptr php_text
+
+/* %% [1.5] DFA */
+
+/* %if-c-only Standard (non-C++) definition */
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* %endif */
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up php_text.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+/* %% [2.0] code to fiddle php_text and php_leng for yymore() goes here \ */\
+	php_leng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+/* %% [3.0] code to copy yytext_ptr to php_text[] goes here, if %array \ */\
+	(yy_c_buf_p) = yy_cp;
+
+/* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
+#define YY_NUM_RULES 18
+#define YY_END_OF_BUFFER 19
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[96] =
+    {   0,
+        0,    0,    0,    0,    3,    3,    4,    4,    4,    4,
+        0,    0,    0,    0,   19,   17,   16,   17,    2,   17,
+        6,   17,    5,    8,   16,    7,   17,   16,   16,   16,
+        1,    0,    0,    3,    4,    4,    4,    4,    0,    9,
+       10,    0,   13,    0,   13,   13,    0,    0,   15,    0,
+        0,    0,    0,    0,    0,    0,   12,    0,   12,   12,
+        0,    0,    0,    0,    0,   13,    0,   14,    0,   12,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       11,    0,    0,   12,    0,   12,   12,    0,   14,   12,
+       12,    0,    0,    0,    0
+
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        2,    2,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    4,    1,    5,    1,    1,    6,    1,
+        1,    7,    1,    1,    8,    9,   10,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,    1,    1,   12,
+        1,   13,    1,   14,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+       15,   16,   17,    1,    9,    1,    9,    9,    9,    9,
+
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    1,   18,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[20] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    3,    3,    1,
+        3,    1,    2,    1,    1,    1,    1,    1,    2
+    } ;
+
+static yyconst flex_int16_t yy_base[102] =
+    {   0,
+        0,   13,  121,  118,    0,    3,    4,    5,    6,    7,
+       27,    0,   20,   21,  124,  193,  193,   26,  193,    8,
+      193,   41,  193,  193,  118,  193,   51,   63,  117,  116,
+      193,   36,   43,  103,  193,   45,   99,   47,   74,  193,
+      193,   49,  193,  103,    0,  102,  103,   88,  193,   51,
+       46,   57,   61,   63,   67,   72,  193,  100,    0,   98,
+       97,   95,   96,   74,    0,    0,   99,  193,   76,    0,
+       16,   82,  109,   66,    0,   83,   86,   69,  122,    0,
+      193,   68,  133,   89,  139,  145,  151,  157,   90,   42,
+        0,  163,   27,    0,  193,  180,  183,    4,    1,  186,
+
+      189
+    } ;
+
+static yyconst flex_int16_t yy_def[102] =
+    {   0,
+       96,   96,    2,    2,    2,    2,    2,    2,    2,    2,
+        2,   11,   11,   11,   95,   95,   95,   95,   95,   95,
+       95,   97,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,   98,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,   95,   97,   95,   95,   99,   95,
+      100,   95,   95,   95,   27,   98,   95,   95,  101,   99,
+      100,  100,   95,   95,   67,  101,  101,   39,  100,   73,
+       95,   95,  101,  100,  100,  100,  100,  100,  101,   86,
+       86,   86,   92,   92,    0,   95,   95,   95,   95,   95,
+
+       95
+    } ;
+
+static yyconst flex_int16_t yy_nxt[213] =
+    {   0,
+       95,   95,   19,   70,   17,   19,   66,   21,   21,   33,
+       34,   23,   23,   17,   17,   20,   17,   17,   20,   22,
+       22,   22,   22,   72,   29,   29,   17,   17,   78,   17,
+       24,   25,   26,   30,   30,   31,   27,   50,   51,   79,
+       28,   32,   36,   37,   33,   34,   53,   37,   55,   56,
+       64,   65,   50,   51,   79,   31,   38,   40,   33,   34,
+       41,   32,   53,   37,   53,   37,   42,   43,   55,   56,
+       44,   45,   68,   46,   95,   64,   65,   47,   57,   81,
+       95,   58,   59,   77,   60,   61,   95,   38,   62,   72,
+       77,   63,   68,   77,   79,   82,   72,   77,   83,   69,
+
+       74,   78,   82,   73,   72,   63,   75,   75,   60,   75,
+       60,   67,   46,   46,   54,   43,   80,   80,   52,   80,
+       49,   48,   39,   95,   18,   57,   84,   18,   95,   85,
+       86,   95,   87,   95,   78,   95,   88,   89,   95,   95,
+       77,   95,   95,   95,   95,   82,   72,   95,   95,   87,
+       95,   79,   90,   91,   95,   91,   95,   78,   72,   95,
+       95,   87,   95,   78,   72,   92,   95,   95,   95,   78,
+       93,   94,   95,   94,   95,   95,   95,   95,   95,   84,
+       16,   16,   16,   35,   35,   35,   71,   95,   71,   76,
+       95,   76,   15,   95,   95,   95,   95,   95,   95,   95,
+
+       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95
+    } ;
+
+static yyconst flex_int16_t yy_chk[213] =
+    {   0,
+        0,    0,    5,   99,    1,    6,   98,    7,    8,   20,
+       20,    9,   10,    1,    1,    5,    1,    2,    6,    7,
+        8,    9,   10,   71,   13,   14,    2,    2,   71,    2,
+       11,   11,   11,   13,   14,   18,   11,   32,   32,   93,
+       11,   18,   22,   22,   33,   33,   36,   36,   38,   38,
+       42,   42,   50,   50,   90,   51,   22,   27,   52,   52,
+       27,   51,   53,   53,   54,   54,   27,   28,   55,   55,
+       28,   28,   82,   28,   56,   64,   64,   28,   39,   74,
+       78,   39,   39,   69,   39,   39,   78,   56,   39,   72,
+       76,   39,   48,   77,   72,   76,   84,   89,   77,   48,
+
+       63,   84,   89,   62,   61,   48,   67,   67,   60,   67,
+       58,   47,   46,   44,   37,   67,   73,   73,   34,   73,
+       30,   29,   25,   15,    4,   73,   79,    3,    0,   79,
+       79,    0,   79,    0,   79,    0,   79,   83,    0,    0,
+       83,    0,    0,    0,    0,   83,   85,    0,    0,   85,
+        0,   85,   86,   86,    0,   86,    0,   86,   87,    0,
+        0,   87,    0,   87,   88,   88,    0,    0,    0,   88,
+       92,   92,    0,   92,    0,    0,    0,    0,    0,   92,
+       96,   96,   96,   97,   97,   97,  100,    0,  100,  101,
+        0,  101,   95,   95,   95,   95,   95,   95,   95,   95,
+
+       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int php__flex_debug;
+int php__flex_debug = 1;
+
+static yyconst flex_int16_t yy_rule_linenum[18] =
+    {   0,
+      114,  124,  125,  135,  140,  145,  151,  152,  153,  154,
+      156,  164,  170,  180,  188,  198,  201
+    } ;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *php_text;
+#line 1 "src/scan-php.l"
+/* Bison Action Scanner                             -*- C -*-
+
+   Copyright (C) 2006-2015 Free Software Foundation, Inc.
+
+   This file is part of Bison, the GNU Compiler Compiler.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+#define YY_NO_INPUT 1
+#line 24 "src/scan-php.l"
+/* Work around a bug in flex 2.5.31.  See Debian bug 333231
+   <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=333231>.  */
+#undef code_wrap
+#define code_wrap() 1
+
+#define FLEX_PREFIX(Id) php_ ## Id
+#include <src/flex-scanner.h>
+
+#include <src/complain.h>
+#include <src/reader.h>
+#include <src/getargs.h>
+#include <src/muscle-tab.h>
+#include <src/scan-code.h>
+#include <src/symlist.h>
+
+#include <c-ctype.h>
+#include <get-errno.h>
+#include <quote.h>
+
+/* The current calling start condition: SC_RULE_ACTION or
+   SC_SYMBOL_ACTION. */
+# define YY_DECL static char *php_lex (code_props *self, int sc_context)
+YY_DECL;
+
+#define YY_USER_ACTION  location_compute (loc, &loc->end, php_text, php_leng);
+
+static char *fetch_type_name (char *cp, char const **type_name,
+                              location dollar_loc);
+
+static void handle_action_dollar (symbol_list *rule, char *cp,
+                                  location dollar_loc);
+static void handle_action_at (symbol_list *rule, char *cp, location at_loc);
+
+/* A string to be pushed to obstack after dollar/at has been handled. */
+static char *ref_tail_fields;
+
+static location the_location;
+static location *loc = &the_location;
+
+/* A string representing the most recent translation.  */
+static char *last_string;
+
+/* True if an untyped $$ or $n was seen.  */
+static bool untyped_var_seen;
+
+/* C and C++ comments in code. */
+
+/* Strings and characters in code. */
+
+/* Whether in a rule or symbol action.  Specifies the translation
+of $ and @.  */
+
+/* POSIX says that a tag must be both an id and a C union member, but
+   historically almost any character is allowed in a tag.  We disallow
+   NUL and newline, as this simplifies our implementation.  We allow
+   "->" as a means to dereference a pointer.  */
+/* Zero or more instances of backslash-newline.  Following GCC, allow
+   white space between the backslash and the newline.  */
+/* C style identifier. Must start with letter. Will be used for
+   named symbol references. Shall be kept synchronized with
+   scan-gram.l "letter" and "id". */
+#line 724 "src/scan-php.c"
+
+#define INITIAL 0
+#define SC_COMMENT 1
+#define SC_LINE_COMMENT 2
+#define SC_STRING 3
+#define SC_CHARACTER 4
+#define SC_RULE_ACTION 5
+#define SC_SYMBOL_ACTION 6
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+/* %if-c-only */
+#include <unistd.h>
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+/* %if-c-only Reentrant structure and macros (non-C++). */
+/* %if-reentrant */
+/* %if-c-only */
+
+static int yy_init_globals (void );
+
+/* %endif */
+/* %if-reentrant */
+/* %endif */
+/* %endif End reentrant structures and macros. */
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int php_lex_destroy (void );
+
+int php_get_debug (void );
+
+void php_set_debug (int debug_flag  );
+
+YY_EXTRA_TYPE php_get_extra (void );
+
+void php_set_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *php_get_in (void );
+
+void php_set_in  (FILE * in_str  );
+
+FILE *php_get_out (void );
+
+void php_set_out  (FILE * out_str  );
+
+yy_size_t php_get_leng (void );
+
+char *php_get_text (void );
+
+int php_get_lineno (void );
+
+void php_set_lineno (int line_number  );
+
+/* %if-bison-bridge */
+/* %endif */
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int php_wrap (void );
+#else
+extern int php_wrap (void );
+#endif
+#endif
+
+/* %not-for-header */
+
+/* %ok-for-header */
+
+/* %endif */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+/* %ok-for-header */
+
+/* %endif */
+#endif
+
+/* %if-c-only */
+
+/* %endif */
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* %if-c-only Standard (non-C++) definition */
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( php_text, php_leng, 1, php_out )) {} } while (0)
+/* %endif */
+/* %if-c++-only C++ definition */
+/* %endif */
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+/* %% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \ */\
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( php_in )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( php_in ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, php_in))==0 && ferror(php_in)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(php_in); \
+			} \
+		}\
+\
+/* %if-c++-only C++ definition \ */\
+/* %endif */
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+/* %if-c-only */
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+#endif
+
+/* %if-tables-serialization structures and prototypes */
+/* %not-for-header */
+
+/* %ok-for-header */
+
+/* %not-for-header */
+
+/* %tables-yydmap generated elements */
+/* %endif */
+/* end tables serialization structures and prototypes */
+
+/* %ok-for-header */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+/* %if-c-only Standard (non-C++) definition */
+
+extern int php_lex (void);
+
+#define YY_DECL int php_lex (void)
+/* %endif */
+/* %if-c++-only C++ definition */
+/* %endif */
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after php_text and php_leng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+/* %% [6.0] YY_RULE_SETUP definition goes here */
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/* %not-for-header */
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! php_in )
+/* %if-c-only */
+			php_in = stdin;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! php_out )
+/* %if-c-only */
+			php_out = stdout;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			php_ensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				php__create_buffer(php_in,YY_BUF_SIZE );
+		}
+
+		php__load_buffer_state( );
+		}
+
+	{
+/* %% [7.0] user's declarations go here */
+#line 96 "src/scan-php.l"
+
+
+
+  /* This scanner is special: it is invoked only once, henceforth
+     is expected to return only once.  This initialization is
+     therefore done once per action to translate. */
+  aver (sc_context == SC_SYMBOL_ACTION
+        || sc_context == SC_RULE_ACTION
+        || sc_context == INITIAL);
+  BEGIN sc_context;
+
+
+  /*------------------------------------------------------------.
+  | Scanning a C comment.  The initial '/ *' is already eaten.  |
+  `------------------------------------------------------------*/
+
+#line 1022 "src/scan-php.c"
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+/* %% [8.0] yymore()-related code goes here */
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of php_text. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+/* %% [9.0] code to set up and find next match goes here */
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 96 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 95 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+/* %% [10.0] code to find the action number goes here */
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+/* %% [11.0] code for php_lineno update goes here */
+
+do_action:	/* This label is used only to access EOF actions. */
+
+/* %% [12.0] debug code goes here */
+		if ( php__flex_debug )
+			{
+			if ( yy_act == 0 )
+				fprintf( stderr, "--scanner backing up\n" );
+			else if ( yy_act < 18 )
+				fprintf( stderr, "--accepting rule at line %ld (\"%s\")\n",
+				         (long)yy_rule_linenum[yy_act], php_text );
+			else if ( yy_act == 18 )
+				fprintf( stderr, "--accepting default rule (\"%s\")\n",
+				         php_text );
+			else if ( yy_act == 19 )
+				fprintf( stderr, "--(end of buffer or a NUL)\n" );
+			else
+				fprintf( stderr, "--EOF (start condition %d)\n", YY_START );
+			}
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+/* %% [13.0] actions go here */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 114 "src/scan-php.l"
+STRING_GROW; BEGIN sc_context;
+	YY_BREAK
+
+/*--------------------------------------------------------------.
+  | Scanning a line comment.  The initial '//' is already eaten.  |
+  `--------------------------------------------------------------*/
+
+
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 124 "src/scan-php.l"
+STRING_GROW; BEGIN sc_context;
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 125 "src/scan-php.l"
+STRING_GROW;
+	YY_BREAK
+
+/*--------------------------------------------.
+  | Scanning user-code characters and strings.  |
+  `--------------------------------------------*/
+
+
+case 4:
+/* rule 4 can match eol */
+YY_RULE_SETUP
+#line 135 "src/scan-php.l"
+STRING_GROW;
+	YY_BREAK
+
+
+
+case 5:
+YY_RULE_SETUP
+#line 140 "src/scan-php.l"
+STRING_GROW; BEGIN sc_context;
+	YY_BREAK
+
+
+
+case 6:
+YY_RULE_SETUP
+#line 145 "src/scan-php.l"
+STRING_GROW; BEGIN sc_context;
+	YY_BREAK
+
+
+
+case 7:
+YY_RULE_SETUP
+#line 151 "src/scan-php.l"
+STRING_GROW; BEGIN SC_CHARACTER;
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 152 "src/scan-php.l"
+STRING_GROW; BEGIN SC_STRING;
+	YY_BREAK
+case 9:
+/* rule 9 can match eol */
+YY_RULE_SETUP
+#line 153 "src/scan-php.l"
+STRING_GROW; BEGIN SC_COMMENT;
+	YY_BREAK
+case 10:
+/* rule 10 can match eol */
+YY_RULE_SETUP
+#line 154 "src/scan-php.l"
+STRING_GROW; BEGIN SC_LINE_COMMENT;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 156 "src/scan-php.l"
+{
+    complain (loc, Wother, _("stray '%s'"), php_text);
+    obstack_escape (&obstack_for_string, php_text);
+  }
+	YY_BREAK
+
+
+
+case 12:
+YY_RULE_SETUP
+#line 164 "src/scan-php.l"
+{
+    ref_tail_fields = NULL;
+    handle_action_dollar (self->rule, php_text + 1, *loc);
+    if (ref_tail_fields)
+      obstack_sgrow (&obstack_for_string, ref_tail_fields);
+  }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 170 "src/scan-php.l"
+{
+    ref_tail_fields = NULL;
+    handle_action_at (self->rule, php_text, *loc);
+    if (ref_tail_fields)
+      obstack_sgrow (&obstack_for_string, ref_tail_fields);
+  }
+	YY_BREAK
+
+
+
+case 14:
+YY_RULE_SETUP
+#line 180 "src/scan-php.l"
+{
+    const char *type_name = NULL;
+    fetch_type_name (php_text + 1, &type_name, *loc)[-1] = 0;
+    obstack_sgrow (&obstack_for_string, "]b4_dollar_dollar(");
+    obstack_quote (&obstack_for_string, type_name);
+    obstack_sgrow (&obstack_for_string, ")[");
+    self->is_value_used = true;
+  }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 188 "src/scan-php.l"
+{
+    obstack_sgrow (&obstack_for_string, "]b4_at_dollar[");
+    muscle_percent_define_ensure("locations", the_location, true);
+  }
+	YY_BREAK
+
+
+
+/* Escape M4 quoting characters in C code.  */
+case 16:
+YY_RULE_SETUP
+#line 198 "src/scan-php.l"
+obstack_escape (&obstack_for_string, php_text);
+	YY_BREAK
+/* By default, grow the string obstack with the input.  */
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+#line 201 "src/scan-php.l"
+STRING_GROW;
+	YY_BREAK
+/* End of processing. */
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(SC_COMMENT):
+case YY_STATE_EOF(SC_LINE_COMMENT):
+case YY_STATE_EOF(SC_STRING):
+case YY_STATE_EOF(SC_CHARACTER):
+case YY_STATE_EOF(SC_RULE_ACTION):
+case YY_STATE_EOF(SC_SYMBOL_ACTION):
+#line 204 "src/scan-php.l"
+STRING_FINISH; return last_string;
+	YY_BREAK
+
+case 18:
+YY_RULE_SETUP
+#line 207 "src/scan-php.l"
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+#line 1262 "src/scan-php.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed php_in at a new source and called
+			 * php_lex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = php_in;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+/* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( php_wrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * php_text, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of user's declarations */
+} /* end of php_lex */
+/* %ok-for-header */
+
+/* %if-c++-only */
+/* %not-for-header */
+
+/* %ok-for-header */
+
+/* %endif */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+/* %if-c-only */
+static int yy_get_next_buffer (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			yy_size_t num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				yy_size_t new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					php_realloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			php_restart(php_in  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) php_realloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+/* %if-c-only */
+/* %not-for-header */
+
+    static yy_state_type yy_get_previous_state (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+/* %% [15.0] code to get the start state into yy_current_state goes here */
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+/* %% [16.0] code to find the next state goes here */
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 19);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 96 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+/* %if-c-only */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register int yy_is_jam;
+    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
+	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 19;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 96 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 95);
+
+		return yy_is_jam ? 0 : yy_current_state;
+}
+
+/* %if-c-only */
+
+/* %endif */
+
+/* %if-c-only */
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					php_restart(php_in );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( php_wrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve php_text */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+/* %% [19.0] update BOL and php_lineno */
+
+	return c;
+}
+/* %if-c-only */
+#endif	/* ifndef YY_NO_INPUT */
+/* %endif */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+/* %if-c-only */
+    void php_restart  (FILE * input_file )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        php_ensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            php__create_buffer(php_in,YY_BUF_SIZE );
+	}
+
+	php__init_buffer(YY_CURRENT_BUFFER,input_file );
+	php__load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+/* %if-c-only */
+    void php__switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		php_pop_buffer_state();
+	 *		php_push_buffer_state(new_buffer);
+     */
+	php_ensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	php__load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (php_wrap()) processing, but the only time this flag
+	 * is looked at is after php_wrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/* %if-c-only */
+static void php__load_buffer_state  (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	php_in = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+/* %if-c-only */
+    YY_BUFFER_STATE php__create_buffer  (FILE * file, int  size )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) php_alloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in php__create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) php_alloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in php__create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	php__init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with php__create_buffer()
+ * 
+ */
+/* %if-c-only */
+    void php__delete_buffer (YY_BUFFER_STATE  b )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		php_free((void *) b->yy_ch_buf  );
+
+	php_free((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a php_restart() or at EOF.
+ */
+/* %if-c-only */
+    static void php__init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+{
+	int oerrno = errno;
+    
+	php__flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then php__init_buffer was _probably_
+     * called from php_restart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+/* %if-c-only */
+
+        b->yy_is_interactive = 0;
+    
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+/* %if-c-only */
+    void php__flush_buffer (YY_BUFFER_STATE  b )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		php__load_buffer_state( );
+}
+
+/* %if-c-or-c++ */
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+/* %if-c-only */
+void php_push_buffer_state (YY_BUFFER_STATE new_buffer )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if (new_buffer == NULL)
+		return;
+
+	php_ensure_buffer_stack();
+
+	/* This block is copied from php__switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from php__switch_to_buffer. */
+	php__load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+/* %if-c-only */
+void php_pop_buffer_state (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	php__delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		php__load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+/* %if-c-only */
+static void php_ensure_buffer_stack (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	yy_size_t num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)php_alloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in php_ensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)php_realloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in php_ensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE php__scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) php_alloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in php__scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	php__switch_to_buffer(b  );
+
+	return b;
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan a string. The next call to php_lex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       php__scan_bytes() instead.
+ */
+YY_BUFFER_STATE php__scan_string (yyconst char * yystr )
+{
+    
+	return php__scan_bytes(yystr,strlen(yystr) );
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan the given bytes. The next call to php_lex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE php__scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	yy_size_t i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) php_alloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in php__scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = php__scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in php__scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+/* %endif */
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+/* %if-c-only */
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up php_text. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		php_text[php_leng] = (yy_hold_char); \
+		(yy_c_buf_p) = php_text + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		php_leng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/* %if-c-only */
+/* %if-reentrant */
+/* %endif */
+
+/** Get the current line number.
+ * 
+ */
+int php_get_lineno  (void)
+{
+        
+    return php_lineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *php_get_in  (void)
+{
+        return php_in;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *php_get_out  (void)
+{
+        return php_out;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+yy_size_t php_get_leng  (void)
+{
+        return php_leng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *php_get_text  (void)
+{
+        return php_text;
+}
+
+/* %if-reentrant */
+/* %endif */
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void php_set_lineno (int  line_number )
+{
+    
+    php_lineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see php__switch_to_buffer
+ */
+void php_set_in (FILE *  in_str )
+{
+        php_in = in_str ;
+}
+
+void php_set_out (FILE *  out_str )
+{
+        php_out = out_str ;
+}
+
+int php_get_debug  (void)
+{
+        return php__flex_debug;
+}
+
+void php_set_debug (int  bdebug )
+{
+        php__flex_debug = bdebug ;
+}
+
+/* %endif */
+
+/* %if-reentrant */
+/* %if-bison-bridge */
+/* %endif */
+/* %endif if-c-only */
+
+/* %if-c-only */
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from php_lex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    php_in = stdin;
+    php_out = stdout;
+#else
+    php_in = (FILE *) 0;
+    php_out = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * php_lex_init()
+     */
+    return 0;
+}
+/* %endif */
+
+/* %if-c-only SNIP! this currently causes conflicts with the c++ scanner */
+/* php_lex_destroy is for both reentrant and non-reentrant scanners. */
+int php_lex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		php__delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		php_pop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	php_free((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * php_lex() is called, initialization will occur. */
+    yy_init_globals( );
+
+/* %if-reentrant */
+/* %endif */
+    return 0;
+}
+/* %endif */
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *php_alloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *php_realloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void php_free (void * ptr )
+{
+	free( (char *) ptr );	/* see php_realloc() for (char *) cast */
+}
+
+/* %if-tables-serialization definitions */
+/* %define-yytables   The name for this specific scanner's tables. */
+#define YYTABLES_NAME "yytables"
+/* %endif */
+
+/* %ok-for-header */
+
+#line 207 "src/scan-php.l"
+
+
+
+static inline bool
+is_dot_or_dash (char ch)
+{
+  return ch == '.' || ch == '-';
+}
+
+static inline bool
+contains_dot_or_dash (const char* p)
+{
+  for (; *p; ++p)
+    if (is_dot_or_dash (*p))
+      return true;
+  return false;
+}
+
+/* Defines a variant of a symbolic name resolution. */
+typedef struct
+{
+  /* Index in symbol list. */
+  unsigned symbol_index;
+
+  /* Matched symbol id and loc. */
+  uniqstr id;
+  location loc;
+
+  /* Hiding named reference. */
+  named_ref* hidden_by;
+
+  /* Error flags. May contain zero (no errors) or
+     a combination of VARIANT_* values. */
+  unsigned err;
+} variant;
+
+/* Set when the variant refers to a symbol hidden
+   by an explicit symbol reference. */
+#define VARIANT_HIDDEN (1 << 0)
+
+/* Set when the variant refers to a symbol containing
+   dots or dashes. Will require explicit bracketing. */
+#define VARIANT_BAD_BRACKETING (1 << 1)
+
+/* Set when the variant refers to a symbol which is
+   not visible from current midrule. */
+#define VARIANT_NOT_VISIBLE_FROM_MIDRULE (1 << 2)
+
+static variant *variant_table = NULL;
+static unsigned variant_table_size = 0;
+static unsigned variant_count = 0;
+
+static variant *
+variant_table_grow (void)
+{
+  ++variant_count;
+  if (variant_count > variant_table_size)
+    {
+      while (variant_count > variant_table_size)
+        variant_table_size = 2 * variant_table_size + 3;
+      variant_table = xnrealloc (variant_table, variant_table_size,
+                                 sizeof *variant_table);
+    }
+  return &variant_table[variant_count - 1];
+}
+
+static void
+variant_table_free (void)
+{
+  free (variant_table);
+  variant_table = NULL;
+  variant_table_size = variant_count = 0;
+}
+
+static char *
+find_prefix_end (const char *prefix, char *begin, char *end)
+{
+  char *ptr = begin;
+
+  for (; *prefix && ptr != end; ++prefix, ++ptr)
+    if (*prefix != *ptr)
+      return 0;
+
+  if (*prefix)
+    return 0;
+
+  return ptr;
+}
+
+static variant *
+variant_add (uniqstr id, location id_loc, unsigned symbol_index,
+             char *cp, char *cp_end, bool explicit_bracketing)
+{
+  char *prefix_end;
+
+  prefix_end = find_prefix_end (id, cp, cp_end);
+  if (prefix_end &&
+      (prefix_end == cp_end ||
+       (!explicit_bracketing && is_dot_or_dash (*prefix_end))))
+    {
+      variant *r = variant_table_grow ();
+      r->symbol_index = symbol_index;
+      r->id = id;
+      r->loc = id_loc;
+      r->hidden_by = NULL;
+      r->err = 0;
+      return r;
+    }
+  else
+    return NULL;
+}
+
+static const char *
+get_at_spec(unsigned symbol_index)
+{
+  static char at_buf[20];
+  if (symbol_index == 0)
+    strcpy (at_buf, "$$");
+  else
+    snprintf (at_buf, sizeof at_buf, "$%u", symbol_index);
+  return at_buf;
+}
+
+static void
+show_sub_message (warnings warning,
+                  const char* cp, bool explicit_bracketing,
+                  int midrule_rhs_index, char dollar_or_at,
+                  unsigned indent, const variant *var)
+{
+  const char *at_spec = get_at_spec (var->symbol_index);
+
+  if (var->err == 0)
+    complain_indent (&var->loc, warning, &indent,
+                     _("refers to: %c%s at %s"), dollar_or_at,
+                     var->id, at_spec);
+  else
+    {
+      static struct obstack msg_buf;
+      const char *tail = explicit_bracketing ? "" : cp + strlen (var->id);
+      const char *id;
+      location id_loc;
+
+      if (var->hidden_by)
+        {
+          id = var->hidden_by->id;
+          id_loc = var->hidden_by->loc;
+        }
+      else
+        {
+          id = var->id;
+          id_loc = var->loc;
+        }
+
+      /* Create the explanation message. */
+      obstack_init (&msg_buf);
+
+      obstack_printf (&msg_buf, _("possibly meant: %c"), dollar_or_at);
+      if (contains_dot_or_dash (id))
+        obstack_printf (&msg_buf, "[%s]", id);
+      else
+        obstack_sgrow (&msg_buf, id);
+      obstack_sgrow (&msg_buf, tail);
+
+      if (var->err & VARIANT_HIDDEN)
+        {
+          obstack_printf (&msg_buf, _(", hiding %c"), dollar_or_at);
+          if (contains_dot_or_dash (var->id))
+            obstack_printf (&msg_buf, "[%s]", var->id);
+          else
+            obstack_sgrow (&msg_buf, var->id);
+          obstack_sgrow (&msg_buf, tail);
+        }
+
+      obstack_printf (&msg_buf, _(" at %s"), at_spec);
+
+      if (var->err & VARIANT_NOT_VISIBLE_FROM_MIDRULE)
+        obstack_printf (&msg_buf,
+                        _(", cannot be accessed from mid-rule action at $%d"),
+                        midrule_rhs_index);
+
+      complain_indent (&id_loc, warning, &indent, "%s",
+                        obstack_finish0 (&msg_buf));
+      obstack_free (&msg_buf, 0);
+    }
+}
+
+static void
+show_sub_messages (warnings warning,
+                   const char* cp, bool explicit_bracketing,
+                   int midrule_rhs_index, char dollar_or_at,
+                   unsigned indent)
+{
+  unsigned i;
+
+  for (i = 0; i < variant_count; ++i)
+    show_sub_message (warning | silent,
+                      cp, explicit_bracketing,
+                      midrule_rhs_index, dollar_or_at,
+                      indent, &variant_table[i]);
+}
+
+/* Returned from "parse_ref" when the reference
+   is inappropriate. */
+#define INVALID_REF (INT_MIN)
+
+/* Returned from "parse_ref" when the reference
+   points to LHS ($$) of the current rule or midrule. */
+#define LHS_REF (INT_MIN + 1)
+
+/* Parse named or positional reference. In case of positional
+   references, can return negative values for $-n "deep" stack
+   accesses. */
+static long int
+parse_ref (char *cp, symbol_list *rule, int rule_length,
+           int midrule_rhs_index, char *text, location text_loc,
+           char dollar_or_at)
+{
+  symbol_list *l;
+  char *cp_end;
+  bool explicit_bracketing;
+  unsigned i;
+  unsigned valid_variants = 0;
+  unsigned valid_variant_index = 0;
+
+  if ('$' == *cp)
+    return LHS_REF;
+
+  if (c_isdigit (*cp) || (*cp == '-' && c_isdigit (* (cp + 1))))
+    {
+      long int num = strtol (cp, &cp, 10);
+      if (1 - INT_MAX + rule_length <= num && num <= rule_length)
+        return num;
+      else
+        {
+          complain (&text_loc, complaint, _("integer out of range: %s"),
+                    quote (text));
+          return INVALID_REF;
+        }
+    }
+
+  if ('[' == *cp)
+    {
+      /* Ignore the brackets. */
+      char *p;
+      for (p = ++cp; *p != ']'; ++p)
+        continue;
+      cp_end = p;
+
+      explicit_bracketing = true;
+    }
+  else
+    {
+      /* Take all characters of the name. */
+      char* p;
+      for (p = cp; *p; ++p)
+        if (is_dot_or_dash (*p))
+          {
+            ref_tail_fields = p;
+            break;
+          }
+      for (p = cp; *p; ++p)
+        continue;
+      cp_end = p;
+
+      explicit_bracketing = false;
+    }
+
+  /* Add all relevant variants. */
+  {
+    unsigned symbol_index;
+    variant_count = 0;
+    for (symbol_index = 0, l = rule; !symbol_list_null (l);
+         ++symbol_index, l = l->next)
+      {
+        variant *var;
+        if (l->content_type != SYMLIST_SYMBOL)
+          continue;
+
+        var = variant_add (l->content.sym->tag, l->sym_loc,
+                           symbol_index, cp, cp_end, explicit_bracketing);
+        if (var && l->named_ref)
+          var->hidden_by = l->named_ref;
+
+        if (l->named_ref)
+          variant_add (l->named_ref->id, l->named_ref->loc,
+                       symbol_index, cp, cp_end, explicit_bracketing);
+      }
+  }
+
+  /* Check errors. */
+  for (i = 0; i < variant_count; ++i)
+    {
+      variant *var = &variant_table[i];
+      unsigned symbol_index = var->symbol_index;
+
+      /* Check visibility from mid-rule actions. */
+      if (midrule_rhs_index != 0
+          && (symbol_index == 0 || midrule_rhs_index < symbol_index))
+        var->err |= VARIANT_NOT_VISIBLE_FROM_MIDRULE;
+
+      /* Check correct bracketing. */
+      if (!explicit_bracketing && contains_dot_or_dash (var->id))
+        var->err |= VARIANT_BAD_BRACKETING;
+
+      /* Check using of hidden symbols. */
+      if (var->hidden_by)
+        var->err |= VARIANT_HIDDEN;
+
+      if (!var->err)
+        {
+          valid_variant_index = i;
+          ++valid_variants;
+        }
+    }
+
+  switch (valid_variants)
+    {
+    case 0:
+      {
+        unsigned len = (explicit_bracketing || !ref_tail_fields) ?
+          cp_end - cp : ref_tail_fields - cp;
+        unsigned indent = 0;
+
+        complain_indent (&text_loc, complaint, &indent,
+                         _("invalid reference: %s"), quote (text));
+        indent += SUB_INDENT;
+        if (len == 0)
+          {
+            location sym_loc = text_loc;
+            sym_loc.start.column += 1;
+            sym_loc.end = sym_loc.start;
+            complain_indent (&sym_loc, complaint, &indent,
+                             _("syntax error after '%c', expecting integer, "
+                               "letter, '_', '[', or '$'"),
+                             dollar_or_at);
+          }
+        else if (midrule_rhs_index)
+          complain_indent (&rule->location, complaint, &indent,
+                           _("symbol not found in production before $%d: "
+                             "%.*s"),
+                           midrule_rhs_index, len, cp);
+        else
+          complain_indent (&rule->location, complaint, &indent,
+                           _("symbol not found in production: %.*s"),
+                           len, cp);
+
+        if (variant_count > 0)
+          show_sub_messages (complaint,
+                             cp, explicit_bracketing, midrule_rhs_index,
+                             dollar_or_at, indent);
+        return INVALID_REF;
+      }
+    case 1:
+      {
+        unsigned indent = 0;
+        if (variant_count > 1)
+          {
+            complain_indent (&text_loc, Wother, &indent,
+                             _("misleading reference: %s"), quote (text));
+            show_sub_messages (Wother,
+                               cp, explicit_bracketing, midrule_rhs_index,
+                               dollar_or_at, indent + SUB_INDENT);
+          }
+        {
+          unsigned symbol_index =
+            variant_table[valid_variant_index].symbol_index;
+          return (symbol_index == midrule_rhs_index) ? LHS_REF : symbol_index;
+        }
+      }
+    case 2:
+    default:
+      {
+        unsigned indent = 0;
+        complain_indent (&text_loc, complaint, &indent,
+                         _("ambiguous reference: %s"), quote (text));
+        show_sub_messages (complaint,
+                           cp, explicit_bracketing, midrule_rhs_index,
+                           dollar_or_at, indent + SUB_INDENT);
+        return INVALID_REF;
+      }
+    }
+}
+
+/* Keeps track of the maximum number of semantic values to the left of
+   a handle (those referenced by $0, $-1, etc.) are required by the
+   semantic actions of this grammar. */
+int max_left_semantic_context_php = 0;
+
+
+/* If CP points to a typename (i.e., <.*?>), set TYPE_NAME to its
+   beginning (i.e., after the opening "<", and return the pointer
+   immediately after it.  */
+
+static
+char *
+fetch_type_name (char *cp, char const **type_name,
+                 location dollar_loc)
+{
+  if (*cp == '<')
+    {
+      *type_name = ++cp;
+      /* Series of non-'>' or "->".  */
+      while (*cp != '>' || cp[-1] == '-')
+        ++cp;
+
+      /* The '>' symbol will be later replaced by '\0'. Original
+         'text' is needed for error messages. */
+      ++cp;
+      if (untyped_var_seen)
+        complain (&dollar_loc, complaint,
+                  _("explicit type given in untyped grammar"));
+      tag_seen = true;
+    }
+  return cp;
+}
+
+/*------------------------------------------------------------------.
+| TEXT is pointing to a wannabee semantic value (i.e., a '$').      |
+|                                                                   |
+| Possible inputs: $[<TYPENAME>]($|integer)                         |
+|                                                                   |
+| Output to OBSTACK_FOR_STRING a reference to this semantic value.  |
+`------------------------------------------------------------------*/
+
+static void
+handle_action_dollar (symbol_list *rule, char *text, location dollar_loc)
+{
+  char const *type_name = NULL;
+  char *cp = text + 1;
+  symbol_list *effective_rule;
+  int effective_rule_length;
+  int n;
+
+  if (rule->midrule_parent_rule)
+    {
+      effective_rule = rule->midrule_parent_rule;
+      effective_rule_length = rule->midrule_parent_rhs_index - 1;
+    }
+  else
+    {
+      effective_rule = rule;
+      effective_rule_length = symbol_list_length (rule->next);
+    }
+
+  /* Get the type name if explicit. */
+  cp = fetch_type_name (cp, &type_name, dollar_loc);
+
+  n = parse_ref (cp, effective_rule, effective_rule_length,
+                 rule->midrule_parent_rhs_index, text, dollar_loc, '$');
+
+  /* End type_name. */
+  if (type_name)
+    cp[-1] = '\0';
+
+  switch (n)
+    {
+    case INVALID_REF:
+      break;
+
+    case LHS_REF:
+      if (!type_name)
+        type_name = symbol_list_n_type_name_get (rule, 0);
+
+      if (!type_name)
+        {
+          if (union_seen | tag_seen)
+            {
+              if (rule->midrule_parent_rule)
+                complain (&dollar_loc, complaint,
+                             _("$$ for the midrule at $%d of %s"
+                               " has no declared type"),
+                             rule->midrule_parent_rhs_index,
+                             quote (effective_rule->content.sym->tag));
+              else
+                complain (&dollar_loc, complaint,
+                          _("$$ of %s has no declared type"),
+                          quote (rule->content.sym->tag));
+            }
+          else
+            untyped_var_seen = true;
+        }
+
+      obstack_sgrow (&obstack_for_string, "]b4_lhs_value(");
+      obstack_quote (&obstack_for_string, type_name);
+      obstack_sgrow (&obstack_for_string, ")[");
+      rule->action_props.is_value_used = true;
+      break;
+
+    default:
+      if (max_left_semantic_context_php < 1 - n)
+        max_left_semantic_context_php = 1 - n;
+      if (!type_name && 0 < n)
+        type_name = symbol_list_n_type_name_get (effective_rule, n);
+      if (!type_name)
+        {
+          if (union_seen | tag_seen)
+            complain (&dollar_loc, complaint,
+                      _("$%s of %s has no declared type"), cp,
+                      quote (effective_rule->content.sym->tag));
+          else
+            untyped_var_seen = true;
+        }
+
+      obstack_printf (&obstack_for_string,
+                      "]b4_rhs_value(%d, %d, ", effective_rule_length, n);
+      obstack_quote (&obstack_for_string, type_name);
+      obstack_sgrow (&obstack_for_string, ")[");
+      if (0 < n)
+        symbol_list_n_get (effective_rule, n)->action_props.is_value_used =
+          true;
+      break;
+    }
+}
+
+
+/*------------------------------------------------------.
+| TEXT is a location token (i.e., a '@...').  Output to |
+| OBSTACK_FOR_STRING a reference to this location.      |
+`------------------------------------------------------*/
+
+static void
+handle_action_at (symbol_list *rule, char *text, location at_loc)
+{
+  char *cp = text + 1;
+  symbol_list *effective_rule;
+  int effective_rule_length;
+  int n;
+
+  if (rule->midrule_parent_rule)
+    {
+      effective_rule = rule->midrule_parent_rule;
+      effective_rule_length = rule->midrule_parent_rhs_index - 1;
+    }
+  else
+    {
+      effective_rule = rule;
+      effective_rule_length = symbol_list_length (rule->next);
+    }
+
+  muscle_percent_define_ensure("locations", at_loc, true);
+
+  n = parse_ref (cp, effective_rule, effective_rule_length,
+                       rule->midrule_parent_rhs_index, text, at_loc, '@');
+  switch (n)
+    {
+    case INVALID_REF:
+      break;
+
+    case LHS_REF:
+      obstack_sgrow (&obstack_for_string, "]b4_lhs_location[");
+      break;
+
+    default:
+      obstack_printf (&obstack_for_string, "]b4_rhs_location(%d, %d)[",
+                      effective_rule_length, n);
+      break;
+    }
+}
+
+
+/*-------------------------.
+| Initialize the scanner.  |
+`-------------------------*/
+
+/* Translate the dollars and ats in \a self, in the context \a sc_context
+   (SC_RULE_ACTION, SC_SYMBOL_ACTION, INITIAL).  */
+
+char const *
+php_translate_action (code_props *self, int sc_context)
+{
+  char *res;
+  static bool initialized = false;
+  if (!initialized)
+    {
+      obstack_init (&obstack_for_string);
+      php__flex_debug = 0;
+      initialized = true;
+    }
+
+  loc->start = loc->end = self->location.start;
+  php__switch_to_buffer (php__scan_string (self->code));
+  res = php_lex (self, sc_context);
+  php__delete_buffer (YY_CURRENT_BUFFER);
+
+  return res;
+}
+
+/*------------------------------------------------------------------------.
+| Implementation of the public interface as documented in "scan-code.h".  |
+`------------------------------------------------------------------------*/
+
+void
+code_props_none_init (code_props *self)
+{
+  *self = code_props_none;
+}
+
+code_props code_props_none = CODE_PROPS_NONE_INIT;
+
+void
+code_props_plain_init (code_props *self, char const *code,
+                       location code_loc)
+{
+  code_props_none_init (self);
+  self->kind = CODE_PROPS_PLAIN;
+  self->code = code;
+  self->location = code_loc;
+}
+
+void
+code_props_symbol_action_init (code_props *self, char const *code,
+                               location code_loc)
+{
+  code_props_none_init (self);
+  self->kind = CODE_PROPS_SYMBOL_ACTION;
+  self->code = code;
+  self->location = code_loc;
+}
+
+void
+code_props_rule_action_init (code_props *self, char const *code,
+                             location code_loc, symbol_list *rule,
+                             named_ref *name, bool is_predicate, bool translate)
+{
+  code_props_none_init (self);
+  if (translate) {
+    self->kind = CODE_PROPS_RULE_ACTION;
+  } else {
+    self->kind = CODE_PROPS_NONE;
+  }
+  self->code = code;
+  self->location = code_loc;
+  self->rule = rule;
+  self->named_ref = name;
+  self->is_predicate = is_predicate;
+}
+
+void
+code_props_translate_code (code_props *self)
+{
+  switch (self->kind)
+    {
+      case CODE_PROPS_NONE:
+        break;
+      case CODE_PROPS_PLAIN:
+        self->code = language->translator (self, INITIAL);
+        break;
+      case CODE_PROPS_SYMBOL_ACTION:
+        self->code = language->translator (self, SC_SYMBOL_ACTION);
+        break;
+      case CODE_PROPS_RULE_ACTION:
+        self->code = language->translator (self, SC_RULE_ACTION);
+        break;
+    }
+}
+
+void
+code_scanner_last_string_free (void)
+{
+  STRING_FREE;
+}
+
+void
+code_scanner_free (void)
+{
+  obstack_free (&obstack_for_string, 0);
+  variant_table_free ();
+
+  // Reclaim Flex's buffers. 
+  php_lex_destroy ();
+}
+
diff -ruN bison-3.0.4/src/scan-php.l bison-3.0.4b/src/scan-php.l
--- bison-3.0.4/src/scan-php.l	1969-12-31 19:00:00.000000000 -0500
+++ bison-3.0.4b/src/scan-php.l	2015-12-30 21:21:41.139904100 -0500
@@ -0,0 +1,876 @@
+/* Bison Action Scanner                             -*- C -*-
+
+   Copyright (C) 2006-2015 Free Software Foundation, Inc.
+
+   This file is part of Bison, the GNU Compiler Compiler.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+%option debug nodefault noinput nounput noyywrap never-interactive
+%option prefix="php_" outfile="lex.yy.c"
+
+%{
+/* Work around a bug in flex 2.5.31.  See Debian bug 333231
+   <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=333231>.  */
+#undef code_wrap
+#define code_wrap() 1
+
+#define FLEX_PREFIX(Id) php_ ## Id
+#include <src/flex-scanner.h>
+
+#include <src/complain.h>
+#include <src/reader.h>
+#include <src/getargs.h>
+#include <src/muscle-tab.h>
+#include <src/scan-code.h>
+#include <src/symlist.h>
+
+#include <c-ctype.h>
+#include <get-errno.h>
+#include <quote.h>
+
+/* The current calling start condition: SC_RULE_ACTION or
+   SC_SYMBOL_ACTION. */
+# define YY_DECL static char *php_lex (code_props *self, int sc_context)
+YY_DECL;
+
+#define YY_USER_ACTION  location_compute (loc, &loc->end, yytext, yyleng);
+
+static char *fetch_type_name (char *cp, char const **type_name,
+                              location dollar_loc);
+
+static void handle_action_dollar (symbol_list *rule, char *cp,
+                                  location dollar_loc);
+static void handle_action_at (symbol_list *rule, char *cp, location at_loc);
+
+/* A string to be pushed to obstack after dollar/at has been handled. */
+static char *ref_tail_fields;
+
+static location the_location;
+static location *loc = &the_location;
+
+/* A string representing the most recent translation.  */
+static char *last_string;
+
+/* True if an untyped $$ or $n was seen.  */
+static bool untyped_var_seen;
+
+%}
+ /* C and C++ comments in code. */
+%x SC_COMMENT SC_LINE_COMMENT
+ /* Strings and characters in code. */
+%x SC_STRING SC_CHARACTER
+ /* Whether in a rule or symbol action.  Specifies the translation
+    of $ and @.  */
+%x SC_RULE_ACTION SC_SYMBOL_ACTION
+
+
+/* POSIX says that a tag must be both an id and a C union member, but
+   historically almost any character is allowed in a tag.  We disallow
+   NUL and newline, as this simplifies our implementation.  We allow
+   "->" as a means to dereference a pointer.  */
+tag      ([^\0\n>]|->)+
+
+/* Zero or more instances of backslash-newline.  Following GCC, allow
+   white space between the backslash and the newline.  */
+splice   (\\[ \f\t\v]*\n)*
+
+/* C style identifier. Must start with letter. Will be used for
+   named symbol references. Shall be kept synchronized with
+   scan-gram.l "letter" and "id". */
+letter    [.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]
+id        {letter}({letter}|[-0-9])*
+ref      -?[0-9]+|{id}|"["{id}"]"|"$"
+
+%%
+
+%{
+  /* This scanner is special: it is invoked only once, henceforth
+     is expected to return only once.  This initialization is
+     therefore done once per action to translate. */
+  aver (sc_context == SC_SYMBOL_ACTION
+        || sc_context == SC_RULE_ACTION
+        || sc_context == INITIAL);
+  BEGIN sc_context;
+%}
+
+  /*------------------------------------------------------------.
+  | Scanning a C comment.  The initial '/ *' is already eaten.  |
+  `------------------------------------------------------------*/
+
+<SC_COMMENT>
+{
+  "*"{splice}"/"  STRING_GROW; BEGIN sc_context;
+}
+
+
+  /*--------------------------------------------------------------.
+  | Scanning a line comment.  The initial '//' is already eaten.  |
+  `--------------------------------------------------------------*/
+
+<SC_LINE_COMMENT>
+{
+  "\n"           STRING_GROW; BEGIN sc_context;
+  {splice}       STRING_GROW;
+}
+
+
+  /*--------------------------------------------.
+  | Scanning user-code characters and strings.  |
+  `--------------------------------------------*/
+
+<SC_CHARACTER,SC_STRING>
+{
+  {splice}|\\{splice}.  STRING_GROW;
+}
+
+<SC_CHARACTER>
+{
+  "'"           STRING_GROW; BEGIN sc_context;
+}
+
+<SC_STRING>
+{
+  "\""          STRING_GROW; BEGIN sc_context;
+}
+
+
+<SC_RULE_ACTION,SC_SYMBOL_ACTION>
+{
+  "'"              STRING_GROW; BEGIN SC_CHARACTER;
+  "\""             STRING_GROW; BEGIN SC_STRING;
+  "/"{splice}"*"   STRING_GROW; BEGIN SC_COMMENT;
+  "/"{splice}"/"   STRING_GROW; BEGIN SC_LINE_COMMENT;
+
+  "$$|$@"  {
+    complain (loc, Wother, _("stray '%s'"), yytext);
+    obstack_escape (&obstack_for_string, yytext);
+  }
+}
+
+<SC_RULE_ACTION>
+{
+  "$$"("<"{tag}">")?{ref}  {
+    ref_tail_fields = NULL;
+    handle_action_dollar (self->rule, yytext + 1, *loc);
+    if (ref_tail_fields)
+      obstack_sgrow (&obstack_for_string, ref_tail_fields);
+  }
+  "@"{ref} {
+    ref_tail_fields = NULL;
+    handle_action_at (self->rule, yytext, *loc);
+    if (ref_tail_fields)
+      obstack_sgrow (&obstack_for_string, ref_tail_fields);
+  }
+}
+
+<SC_SYMBOL_ACTION>
+{
+  "$$"("<"{tag}">")?"$" {
+    const char *type_name = NULL;
+    fetch_type_name (yytext + 1, &type_name, *loc)[-1] = 0;
+    obstack_sgrow (&obstack_for_string, "]b4_dollar_dollar(");
+    obstack_quote (&obstack_for_string, type_name);
+    obstack_sgrow (&obstack_for_string, ")[");
+    self->is_value_used = true;
+  }
+  "@$" {
+    obstack_sgrow (&obstack_for_string, "]b4_at_dollar[");
+    muscle_percent_define_ensure("locations", the_location, true);
+  }
+}
+
+
+<*>
+{
+  /* Escape M4 quoting characters in C code.  */
+  [$@\[\]]    obstack_escape (&obstack_for_string, yytext);
+
+  /* By default, grow the string obstack with the input.  */
+  .|\n        STRING_GROW;
+
+ /* End of processing. */
+  <<EOF>>     STRING_FINISH; return last_string;
+}
+
+%%
+
+static inline bool
+is_dot_or_dash (char ch)
+{
+  return ch == '.' || ch == '-';
+}
+
+static inline bool
+contains_dot_or_dash (const char* p)
+{
+  for (; *p; ++p)
+    if (is_dot_or_dash (*p))
+      return true;
+  return false;
+}
+
+/* Defines a variant of a symbolic name resolution. */
+typedef struct
+{
+  /* Index in symbol list. */
+  unsigned symbol_index;
+
+  /* Matched symbol id and loc. */
+  uniqstr id;
+  location loc;
+
+  /* Hiding named reference. */
+  named_ref* hidden_by;
+
+  /* Error flags. May contain zero (no errors) or
+     a combination of VARIANT_* values. */
+  unsigned err;
+} variant;
+
+/* Set when the variant refers to a symbol hidden
+   by an explicit symbol reference. */
+#define VARIANT_HIDDEN (1 << 0)
+
+/* Set when the variant refers to a symbol containing
+   dots or dashes. Will require explicit bracketing. */
+#define VARIANT_BAD_BRACKETING (1 << 1)
+
+/* Set when the variant refers to a symbol which is
+   not visible from current midrule. */
+#define VARIANT_NOT_VISIBLE_FROM_MIDRULE (1 << 2)
+
+static variant *variant_table = NULL;
+static unsigned variant_table_size = 0;
+static unsigned variant_count = 0;
+
+static variant *
+variant_table_grow (void)
+{
+  ++variant_count;
+  if (variant_count > variant_table_size)
+    {
+      while (variant_count > variant_table_size)
+        variant_table_size = 2 * variant_table_size + 3;
+      variant_table = xnrealloc (variant_table, variant_table_size,
+                                 sizeof *variant_table);
+    }
+  return &variant_table[variant_count - 1];
+}
+
+static void
+variant_table_free (void)
+{
+  free (variant_table);
+  variant_table = NULL;
+  variant_table_size = variant_count = 0;
+}
+
+static char *
+find_prefix_end (const char *prefix, char *begin, char *end)
+{
+  char *ptr = begin;
+
+  for (; *prefix && ptr != end; ++prefix, ++ptr)
+    if (*prefix != *ptr)
+      return 0;
+
+  if (*prefix)
+    return 0;
+
+  return ptr;
+}
+
+static variant *
+variant_add (uniqstr id, location id_loc, unsigned symbol_index,
+             char *cp, char *cp_end, bool explicit_bracketing)
+{
+  char *prefix_end;
+
+  prefix_end = find_prefix_end (id, cp, cp_end);
+  if (prefix_end &&
+      (prefix_end == cp_end ||
+       (!explicit_bracketing && is_dot_or_dash (*prefix_end))))
+    {
+      variant *r = variant_table_grow ();
+      r->symbol_index = symbol_index;
+      r->id = id;
+      r->loc = id_loc;
+      r->hidden_by = NULL;
+      r->err = 0;
+      return r;
+    }
+  else
+    return NULL;
+}
+
+static const char *
+get_at_spec(unsigned symbol_index)
+{
+  static char at_buf[20];
+  if (symbol_index == 0)
+    strcpy (at_buf, "$$");
+  else
+    snprintf (at_buf, sizeof at_buf, "$%u", symbol_index);
+  return at_buf;
+}
+
+static void
+show_sub_message (warnings warning,
+                  const char* cp, bool explicit_bracketing,
+                  int midrule_rhs_index, char dollar_or_at,
+                  unsigned indent, const variant *var)
+{
+  const char *at_spec = get_at_spec (var->symbol_index);
+
+  if (var->err == 0)
+    complain_indent (&var->loc, warning, &indent,
+                     _("refers to: %c%s at %s"), dollar_or_at,
+                     var->id, at_spec);
+  else
+    {
+      static struct obstack msg_buf;
+      const char *tail = explicit_bracketing ? "" : cp + strlen (var->id);
+      const char *id;
+      location id_loc;
+
+      if (var->hidden_by)
+        {
+          id = var->hidden_by->id;
+          id_loc = var->hidden_by->loc;
+        }
+      else
+        {
+          id = var->id;
+          id_loc = var->loc;
+        }
+
+      /* Create the explanation message. */
+      obstack_init (&msg_buf);
+
+      obstack_printf (&msg_buf, _("possibly meant: %c"), dollar_or_at);
+      if (contains_dot_or_dash (id))
+        obstack_printf (&msg_buf, "[%s]", id);
+      else
+        obstack_sgrow (&msg_buf, id);
+      obstack_sgrow (&msg_buf, tail);
+
+      if (var->err & VARIANT_HIDDEN)
+        {
+          obstack_printf (&msg_buf, _(", hiding %c"), dollar_or_at);
+          if (contains_dot_or_dash (var->id))
+            obstack_printf (&msg_buf, "[%s]", var->id);
+          else
+            obstack_sgrow (&msg_buf, var->id);
+          obstack_sgrow (&msg_buf, tail);
+        }
+
+      obstack_printf (&msg_buf, _(" at %s"), at_spec);
+
+      if (var->err & VARIANT_NOT_VISIBLE_FROM_MIDRULE)
+        obstack_printf (&msg_buf,
+                        _(", cannot be accessed from mid-rule action at $%d"),
+                        midrule_rhs_index);
+
+      complain_indent (&id_loc, warning, &indent, "%s",
+                        obstack_finish0 (&msg_buf));
+      obstack_free (&msg_buf, 0);
+    }
+}
+
+static void
+show_sub_messages (warnings warning,
+                   const char* cp, bool explicit_bracketing,
+                   int midrule_rhs_index, char dollar_or_at,
+                   unsigned indent)
+{
+  unsigned i;
+
+  for (i = 0; i < variant_count; ++i)
+    show_sub_message (warning | silent,
+                      cp, explicit_bracketing,
+                      midrule_rhs_index, dollar_or_at,
+                      indent, &variant_table[i]);
+}
+
+/* Returned from "parse_ref" when the reference
+   is inappropriate. */
+#define INVALID_REF (INT_MIN)
+
+/* Returned from "parse_ref" when the reference
+   points to LHS ($$) of the current rule or midrule. */
+#define LHS_REF (INT_MIN + 1)
+
+/* Parse named or positional reference. In case of positional
+   references, can return negative values for $-n "deep" stack
+   accesses. */
+static long int
+parse_ref (char *cp, symbol_list *rule, int rule_length,
+           int midrule_rhs_index, char *text, location text_loc,
+           char dollar_or_at)
+{
+  symbol_list *l;
+  char *cp_end;
+  bool explicit_bracketing;
+  unsigned i;
+  unsigned valid_variants = 0;
+  unsigned valid_variant_index = 0;
+
+  if ('$' == *cp)
+    return LHS_REF;
+
+  if (c_isdigit (*cp) || (*cp == '-' && c_isdigit (* (cp + 1))))
+    {
+      long int num = strtol (cp, &cp, 10);
+      if (1 - INT_MAX + rule_length <= num && num <= rule_length)
+        return num;
+      else
+        {
+          complain (&text_loc, complaint, _("integer out of range: %s"),
+                    quote (text));
+          return INVALID_REF;
+        }
+    }
+
+  if ('[' == *cp)
+    {
+      /* Ignore the brackets. */
+      char *p;
+      for (p = ++cp; *p != ']'; ++p)
+        continue;
+      cp_end = p;
+
+      explicit_bracketing = true;
+    }
+  else
+    {
+      /* Take all characters of the name. */
+      char* p;
+      for (p = cp; *p; ++p)
+        if (is_dot_or_dash (*p))
+          {
+            ref_tail_fields = p;
+            break;
+          }
+      for (p = cp; *p; ++p)
+        continue;
+      cp_end = p;
+
+      explicit_bracketing = false;
+    }
+
+  /* Add all relevant variants. */
+  {
+    unsigned symbol_index;
+    variant_count = 0;
+    for (symbol_index = 0, l = rule; !symbol_list_null (l);
+         ++symbol_index, l = l->next)
+      {
+        variant *var;
+        if (l->content_type != SYMLIST_SYMBOL)
+          continue;
+
+        var = variant_add (l->content.sym->tag, l->sym_loc,
+                           symbol_index, cp, cp_end, explicit_bracketing);
+        if (var && l->named_ref)
+          var->hidden_by = l->named_ref;
+
+        if (l->named_ref)
+          variant_add (l->named_ref->id, l->named_ref->loc,
+                       symbol_index, cp, cp_end, explicit_bracketing);
+      }
+  }
+
+  /* Check errors. */
+  for (i = 0; i < variant_count; ++i)
+    {
+      variant *var = &variant_table[i];
+      unsigned symbol_index = var->symbol_index;
+
+      /* Check visibility from mid-rule actions. */
+      if (midrule_rhs_index != 0
+          && (symbol_index == 0 || midrule_rhs_index < symbol_index))
+        var->err |= VARIANT_NOT_VISIBLE_FROM_MIDRULE;
+
+      /* Check correct bracketing. */
+      if (!explicit_bracketing && contains_dot_or_dash (var->id))
+        var->err |= VARIANT_BAD_BRACKETING;
+
+      /* Check using of hidden symbols. */
+      if (var->hidden_by)
+        var->err |= VARIANT_HIDDEN;
+
+      if (!var->err)
+        {
+          valid_variant_index = i;
+          ++valid_variants;
+        }
+    }
+
+  switch (valid_variants)
+    {
+    case 0:
+      {
+        unsigned len = (explicit_bracketing || !ref_tail_fields) ?
+          cp_end - cp : ref_tail_fields - cp;
+        unsigned indent = 0;
+
+        complain_indent (&text_loc, complaint, &indent,
+                         _("invalid reference: %s"), quote (text));
+        indent += SUB_INDENT;
+        if (len == 0)
+          {
+            location sym_loc = text_loc;
+            sym_loc.start.column += 1;
+            sym_loc.end = sym_loc.start;
+            complain_indent (&sym_loc, complaint, &indent,
+                             _("syntax error after '%c', expecting integer, "
+                               "letter, '_', '[', or '$'"),
+                             dollar_or_at);
+          }
+        else if (midrule_rhs_index)
+          complain_indent (&rule->location, complaint, &indent,
+                           _("symbol not found in production before $%d: "
+                             "%.*s"),
+                           midrule_rhs_index, len, cp);
+        else
+          complain_indent (&rule->location, complaint, &indent,
+                           _("symbol not found in production: %.*s"),
+                           len, cp);
+
+        if (variant_count > 0)
+          show_sub_messages (complaint,
+                             cp, explicit_bracketing, midrule_rhs_index,
+                             dollar_or_at, indent);
+        return INVALID_REF;
+      }
+    case 1:
+      {
+        unsigned indent = 0;
+        if (variant_count > 1)
+          {
+            complain_indent (&text_loc, Wother, &indent,
+                             _("misleading reference: %s"), quote (text));
+            show_sub_messages (Wother,
+                               cp, explicit_bracketing, midrule_rhs_index,
+                               dollar_or_at, indent + SUB_INDENT);
+          }
+        {
+          unsigned symbol_index =
+            variant_table[valid_variant_index].symbol_index;
+          return (symbol_index == midrule_rhs_index) ? LHS_REF : symbol_index;
+        }
+      }
+    case 2:
+    default:
+      {
+        unsigned indent = 0;
+        complain_indent (&text_loc, complaint, &indent,
+                         _("ambiguous reference: %s"), quote (text));
+        show_sub_messages (complaint,
+                           cp, explicit_bracketing, midrule_rhs_index,
+                           dollar_or_at, indent + SUB_INDENT);
+        return INVALID_REF;
+      }
+    }
+}
+
+/* Keeps track of the maximum number of semantic values to the left of
+   a handle (those referenced by $0, $-1, etc.) are required by the
+   semantic actions of this grammar. */
+int max_left_semantic_context_php = 0;
+
+
+/* If CP points to a typename (i.e., <.*?>), set TYPE_NAME to its
+   beginning (i.e., after the opening "<", and return the pointer
+   immediately after it.  */
+
+static
+char *
+fetch_type_name (char *cp, char const **type_name,
+                 location dollar_loc)
+{
+  if (*cp == '<')
+    {
+      *type_name = ++cp;
+      /* Series of non-'>' or "->".  */
+      while (*cp != '>' || cp[-1] == '-')
+        ++cp;
+
+      /* The '>' symbol will be later replaced by '\0'. Original
+         'text' is needed for error messages. */
+      ++cp;
+      if (untyped_var_seen)
+        complain (&dollar_loc, complaint,
+                  _("explicit type given in untyped grammar"));
+      tag_seen = true;
+    }
+  return cp;
+}
+
+/*------------------------------------------------------------------.
+| TEXT is pointing to a wannabee semantic value (i.e., a '$').      |
+|                                                                   |
+| Possible inputs: $[<TYPENAME>]($|integer)                         |
+|                                                                   |
+| Output to OBSTACK_FOR_STRING a reference to this semantic value.  |
+`------------------------------------------------------------------*/
+
+static void
+handle_action_dollar (symbol_list *rule, char *text, location dollar_loc)
+{
+  char const *type_name = NULL;
+  char *cp = text + 1;
+  symbol_list *effective_rule;
+  int effective_rule_length;
+  int n;
+
+  if (rule->midrule_parent_rule)
+    {
+      effective_rule = rule->midrule_parent_rule;
+      effective_rule_length = rule->midrule_parent_rhs_index - 1;
+    }
+  else
+    {
+      effective_rule = rule;
+      effective_rule_length = symbol_list_length (rule->next);
+    }
+
+  /* Get the type name if explicit. */
+  cp = fetch_type_name (cp, &type_name, dollar_loc);
+
+  n = parse_ref (cp, effective_rule, effective_rule_length,
+                 rule->midrule_parent_rhs_index, text, dollar_loc, '$');
+
+  /* End type_name. */
+  if (type_name)
+    cp[-1] = '\0';
+
+  switch (n)
+    {
+    case INVALID_REF:
+      break;
+
+    case LHS_REF:
+      if (!type_name)
+        type_name = symbol_list_n_type_name_get (rule, 0);
+
+      if (!type_name)
+        {
+          if (union_seen | tag_seen)
+            {
+              if (rule->midrule_parent_rule)
+                complain (&dollar_loc, complaint,
+                             _("$$ for the midrule at $%d of %s"
+                               " has no declared type"),
+                             rule->midrule_parent_rhs_index,
+                             quote (effective_rule->content.sym->tag));
+              else
+                complain (&dollar_loc, complaint,
+                          _("$$ of %s has no declared type"),
+                          quote (rule->content.sym->tag));
+            }
+          else
+            untyped_var_seen = true;
+        }
+
+      obstack_sgrow (&obstack_for_string, "]b4_lhs_value(");
+      obstack_quote (&obstack_for_string, type_name);
+      obstack_sgrow (&obstack_for_string, ")[");
+      rule->action_props.is_value_used = true;
+      break;
+
+    default:
+      if (max_left_semantic_context_php < 1 - n)
+        max_left_semantic_context_php = 1 - n;
+      if (!type_name && 0 < n)
+        type_name = symbol_list_n_type_name_get (effective_rule, n);
+      if (!type_name)
+        {
+          if (union_seen | tag_seen)
+            complain (&dollar_loc, complaint,
+                      _("$%s of %s has no declared type"), cp,
+                      quote (effective_rule->content.sym->tag));
+          else
+            untyped_var_seen = true;
+        }
+
+      obstack_printf (&obstack_for_string,
+                      "]b4_rhs_value(%d, %d, ", effective_rule_length, n);
+      obstack_quote (&obstack_for_string, type_name);
+      obstack_sgrow (&obstack_for_string, ")[");
+      if (0 < n)
+        symbol_list_n_get (effective_rule, n)->action_props.is_value_used =
+          true;
+      break;
+    }
+}
+
+
+/*------------------------------------------------------.
+| TEXT is a location token (i.e., a '@...').  Output to |
+| OBSTACK_FOR_STRING a reference to this location.      |
+`------------------------------------------------------*/
+
+static void
+handle_action_at (symbol_list *rule, char *text, location at_loc)
+{
+  char *cp = text + 1;
+  symbol_list *effective_rule;
+  int effective_rule_length;
+  int n;
+
+  if (rule->midrule_parent_rule)
+    {
+      effective_rule = rule->midrule_parent_rule;
+      effective_rule_length = rule->midrule_parent_rhs_index - 1;
+    }
+  else
+    {
+      effective_rule = rule;
+      effective_rule_length = symbol_list_length (rule->next);
+    }
+
+  muscle_percent_define_ensure("locations", at_loc, true);
+
+  n = parse_ref (cp, effective_rule, effective_rule_length,
+                       rule->midrule_parent_rhs_index, text, at_loc, '@');
+  switch (n)
+    {
+    case INVALID_REF:
+      break;
+
+    case LHS_REF:
+      obstack_sgrow (&obstack_for_string, "]b4_lhs_location[");
+      break;
+
+    default:
+      obstack_printf (&obstack_for_string, "]b4_rhs_location(%d, %d)[",
+                      effective_rule_length, n);
+      break;
+    }
+}
+
+
+/*-------------------------.
+| Initialize the scanner.  |
+`-------------------------*/
+
+/* Translate the dollars and ats in \a self, in the context \a sc_context
+   (SC_RULE_ACTION, SC_SYMBOL_ACTION, INITIAL).  */
+
+char const *
+php_translate_action (code_props *self, int sc_context)
+{
+  char *res;
+  static bool initialized = false;
+  if (!initialized)
+    {
+      obstack_init (&obstack_for_string);
+      yy_flex_debug = 0;
+      initialized = true;
+    }
+
+  loc->start = loc->end = self->location.start;
+  yy_switch_to_buffer (yy_scan_string (self->code));
+  res = php_lex (self, sc_context);
+  yy_delete_buffer (YY_CURRENT_BUFFER);
+
+  return res;
+}
+
+/*------------------------------------------------------------------------.
+| Implementation of the public interface as documented in "scan-code.h".  |
+`------------------------------------------------------------------------*/
+
+void
+code_props_none_init (code_props *self)
+{
+  *self = code_props_none;
+}
+
+code_props code_props_none = CODE_PROPS_NONE_INIT;
+
+void
+code_props_plain_init (code_props *self, char const *code,
+                       location code_loc)
+{
+  code_props_none_init (self);
+  self->kind = CODE_PROPS_PLAIN;
+  self->code = code;
+  self->location = code_loc;
+}
+
+void
+code_props_symbol_action_init (code_props *self, char const *code,
+                               location code_loc)
+{
+  code_props_none_init (self);
+  self->kind = CODE_PROPS_SYMBOL_ACTION;
+  self->code = code;
+  self->location = code_loc;
+}
+
+void
+code_props_rule_action_init (code_props *self, char const *code,
+                             location code_loc, symbol_list *rule,
+                             named_ref *name, bool is_predicate, bool translate)
+{
+  code_props_none_init (self);
+  if (translate) {
+    self->kind = CODE_PROPS_RULE_ACTION;
+  } else {
+    self->kind = CODE_PROPS_NONE;
+  }
+  self->code = code;
+  self->location = code_loc;
+  self->rule = rule;
+  self->named_ref = name;
+  self->is_predicate = is_predicate;
+}
+
+void
+code_props_translate_code (code_props *self)
+{
+  switch (self->kind)
+    {
+      case CODE_PROPS_NONE:
+        break;
+      case CODE_PROPS_PLAIN:
+        self->code = language->translator (self, INITIAL);
+        break;
+      case CODE_PROPS_SYMBOL_ACTION:
+        self->code = language->translator (self, SC_SYMBOL_ACTION);
+        break;
+      case CODE_PROPS_RULE_ACTION:
+        self->code = language->translator (self, SC_RULE_ACTION);
+        break;
+    }
+}
+
+void
+code_scanner_last_string_free (void)
+{
+  STRING_FREE;
+}
+
+void
+code_scanner_free (void)
+{
+  obstack_free (&obstack_for_string, 0);
+  variant_table_free ();
+
+  // Reclaim Flex's buffers. 
+  yylex_destroy ();
+}
diff -ruN bison-3.0.4/src/scan-php-c.c bison-3.0.4b/src/scan-php-c.c
--- bison-3.0.4/src/scan-php-c.c	1969-12-31 19:00:00.000000000 -0500
+++ bison-3.0.4b/src/scan-php-c.c	2015-12-30 19:43:27.539832800 -0500
@@ -0,0 +1,3 @@
+#include <config.h>
+#include "system.h"
+#include "src/scan-php.c"
